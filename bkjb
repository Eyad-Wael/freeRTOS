








#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include "diag/trace.h"
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "timers.h"
#include <string.h>
#include "semphr.h"

#define CCM_RAM __attribute__((section(".ccmram")))

// ----------------------------------------------------------------------------

#include "led.h"

#define HEADER_SIZE_BYTES   16
#define L1_BYTES            500
#define L2_BYTES            1500
#define K                   40 //ack size
#define PACKET_GEN_INTERVAL 100 // initially
#define TIMEOUT_PERIOD      200
#define MAX_RETRIES         4
#define C_LINK_CAPACITY     100000
#define PROP_DELAY_MS       5
#define P_DROP_PERCENT      1
#define P_DROP_SCALE        100
#define P_ACK               1
#define QUEUE_SIZE          40
#define PACKET_DATA_LEN     20
#define NO_OF_PACKETS       100
//#define MAX_NO_OF_PACKETS   100
#define TX_BUFFER_SIZE 		20
#define PACKET_ARR 400
#define ACK_ARR 200
#define BUFFER_ARR 200


// ----------------------------------------------------------------------------
// Type Definitions

typedef struct {
    int32_t from, to;
    int32_t seq;
    int16_t size, retries;
    
    char    data[PACKET_DATA_LEN];
uint8_t in_use;
} Packet;

typedef struct {
    int32_t from, to;
    int32_t seq;
    int16_t size, retries;
    bool    isAck;
uint8_t in_use;
} ACK;


typedef struct {
    Packet* pkt;
    TimerHandle_t timer;
    
} BUFFER;



typedef struct {
    int32_t myId;
    int32_t seq3, seq4;
} SenderState;


// ----------------------------------------------------------------------------
//  Variables
static Packet pkt_arr[PACKET_ARR]=0;
static ACK ack_arr[ACK_ARR]=0;
static BUFFER buf_arr[BUFFER_ARR]=0;
//static bool             rx3_seenSeq[NO_OF_PACKETS];
//static bool             rx4_seenSeq[NO_OF_PACKETS];
static uint32_t         total_transmissions       = 0;
static uint32_t         total_dropped_max_retries = 0;
static QueueHandle_t    qToSwitch, qToRx3, qToRx4, qToSwitch_ForACKs, qToSender1, qToSender2;
static SemaphoreHandle_t stats_mutex;
static SemaphoreHandle_t buf_mutex;
static int32_t          total_received     = 0;
static int32_t          total_lost         = 0;
static uint32_t         total_bytes_received = 0;
static TickType_t       startTick          = 0;
static SenderState      senderStates[2];

const char* message_pool[] = {
    "eyad",
	"abdelrahman",
    "second year",
    "embeded project",
    "Dr.Khaled Fouad",
    "cairo university"
};
#define MESSAGE_POOL_SIZE (sizeof(message_pool)/sizeof(message_pool[0]))

int txbuf_find_seq(SenderState *state, int32_t seq) {
    for (int i = 0; i < TX_BUFFER_SIZE; ++i)
        if (state->txbuf[i].in_use && state->txbuf[i].pkt && state->txbuf[i].pkt->seq == seq)
            return i;
    return -1;
}
void txbuf_remove(SenderState *state, int idx) {
    if (state->txbuf[idx].timer) { TimerInfo *info = (TimerInfo *) pvTimerGetTimerID(state->txbuf[idx].timer);
    	xTimerStop(state->txbuf[idx].timer, 0); xTimerDelete(state->txbuf[idx].timer, 0);
    	if (info) vPortFree(info);}
    if (state->txbuf[idx].pkt) { vPortFree(state->txbuf[idx].pkt); }
    state->txbuf[idx].pkt = NULL;
    state->txbuf[idx].timer = NULL;
    state->txbuf[idx].retries = 0;
    state->txbuf[idx].in_use = false;
}

static void set_random_packet_data(Packet* pkt) {
    if (!pkt) return;
    int idx = rand() % MESSAGE_POOL_SIZE;
    strncpy(pkt->data, message_pool[idx], PACKET_DATA_LEN - 1);
    pkt->data[PACKET_DATA_LEN - 1] = '\0';
}

static void print_final_stats(void) {
    int32_t total = total_received + total_lost;
    int32_t pct_int = 0, pct_frac = 0;

    if (total > 0) {
        int32_t pct_percent = (10000 * total_lost) / total;
        pct_int = pct_percent / 100;
        pct_frac = pct_percent % 100;
    }

    printf("=== Simulation Complete ===\n");
    printf("Total received packets: %ld\n", (long)total_received);
    printf("Total lost packets: %ld\n", (long)total_lost);
    printf("Loss percentage: %ld.%02ld%%\n", (long)pct_int, (long)pct_frac);

    TickType_t endTick = xTaskGetTickCount();
    TickType_t deltaTicks = endTick - startTick;

    if (deltaTicks == 0) {
        printf("Throughput = 0 bytes/sec (elapsed time = 0 ticks)\n");
        return;
    }

    uint32_t throughput_bps = ((uint32_t)total_bytes_received * (uint32_t)configTICK_RATE_HZ) / (uint32_t)deltaTicks;
    printf("Throughput = %lu bytes/sec\n", (unsigned long)throughput_bps);
    uint32_t avg_transmissions_per_packet = 0;
    if (total_received > 0) {
        avg_transmissions_per_packet = total_transmissions / total_received;
    }
    printf("Average number of transmissions per packet: %lu\n", (unsigned long)avg_transmissions_per_packet);
    printf("Packets dropped after exceeding max retries (%d): %lu\n",
        MAX_RETRIES, (unsigned long)total_dropped_max_retries);

}

static void CheckAndReportStatsAndStop(void) {
    static bool reported = false;
    if (reported) return;

    xSemaphoreTake(stats_mutex, portMAX_DELAY);
    int32_t total = total_received + total_lost;
    xSemaphoreGive(stats_mutex);

    if (total >= MAX_NO_OF_PACKETS) {
        reported = true;
        print_final_stats();
        vTaskEndScheduler();
    }
}
    // ----------------------------------------------------------------------------
    // Sender

    void SenderRetransmitCallback(TimerHandle_t t) {

    	 printf("DEBUG: SenderRetransmitCallback\n");
    	TimerInfo *info = (TimerInfo *)pvTimerGetTimerID(t);
   	    SenderState *state = info->state;



    	    int slot = info->slot;
    	   printf("DEBUG: SenderRetransmitCallback before semaphore\n");
    	    xSemaphoreTake(buf_mutex, portMAX_DELAY);
    	    printf("DEBUG: SenderRetransmitCallback after semaphore\n");
    	    if (!state->txbuf[slot].in_use || !state->txbuf[slot].pkt){
    	    	 printf("DEBUG: SenderRetransmitCallback first if cond\n");
    	    	 xSemaphoreGive(buf_mutex);

    	    	return;}
    	    state->txbuf[slot].retries++;
    	        printf("DEBUG: Retransmit attempt %d for seq %ld\n",
    	               state->txbuf[slot].retries, (long)state->txbuf[slot].pkt->seq);
    	        if (state->txbuf[slot].retries > MAX_RETRIES) {
    	        	printf("DEBUG: Max retries exceeded for seq %ld\n", (long)state->txbuf[slot].pkt->seq);
    	            txbuf_remove(state, slot);
    	            xSemaphoreGive(buf_mutex);
    	            xSemaphoreTake(stats_mutex, portMAX_DELAY);
    	            total_dropped_max_retries++;
    	            total_lost++;
    	            xSemaphoreGive(stats_mutex);
    	            CheckAndReportStatsAndStop();
    	          //     printf("DEBUG: SenderRetransmitCallback DROPPED pkt seq=%ld to=%ld, sliding base\n", (long)dropped_seq, (long)dropped_to);
    	            return;
    	        }



        // Retransmit
    	        Packet *pkt_copy = state->txbuf[slot].pkt;
    	        printf("DEBUG: SenderRetransmitCallback retransmit\n");
    	        xQueueSend(qToSwitch, &state->txbuf[slot].pkt, 0);
    	        xSemaphoreTake(stats_mutex, portMAX_DELAY);
    	          total_transmissions++;
    	          xSemaphoreGive(stats_mutex);

    	          // Restart the timer for next timeout
    	          xTimerReset(state->txbuf[slot].timer, 0);
    	           xSemaphoreGive(buf_mutex);

     	        }


    static void send_and_buffer(SenderState *state, Packet *pkt) {
    	printf("DEBUG: Sendand buffer\n");

        int idx = -1;
        xSemaphoreTake(buf_mutex, portMAX_DELAY);
         for (int i = 0; i < TX_BUFFER_SIZE; ++i) {
             printf("DEBUG: Sendand buffer for\n");
             if (!state->txbuf[i].in_use) {
                 printf("DEBUG: Sendand buffer if \n");
                 idx = i;
                 break;
             }
        } if (idx < 0) {
            printf("Sender %ld: BUFFER is  full, dropping seq %ld\n",
                (long)pkt->from, (long)pkt->seq);
            vPortFree(pkt);
            xSemaphoreGive(buf_mutex);
            return;
        }
        printf("DEBUG: Sendand buffer after for \n");
        	state->txbuf[idx].pkt     = pkt;
           state->txbuf[idx].retries = 0;
           state->txbuf[idx].in_use  = true;

        TimerInfo *cbinfo = pvPortMalloc(sizeof(TimerInfo));
        if (!cbinfo) {
            printf("Failed to allocate TimerInfo\n");
            vPortFree(pkt);
            state->txbuf[idx].pkt = NULL;
            state->txbuf[idx].in_use = false;
            xSemaphoreGive(buf_mutex);
            return;
        }
           cbinfo->state = state;
           cbinfo->slot = idx;


           state->txbuf[idx].timer = xTimerCreate(
               "PktTimer",
               pdMS_TO_TICKS(TIMEOUT_PERIOD),
               pdFALSE,
               (void *)cbinfo,
               SenderRetransmitCallback
           );


           if (!state->txbuf[idx].timer) {
               printf("DEBUG: Sendand buffer after create timer failure\n");
               vPortFree(cbinfo);
               vPortFree(pkt);
               state->txbuf[idx].pkt    = NULL;
               state->txbuf[idx].in_use = false;
               xSemaphoreGive(buf_mutex);
               return;
           }
           xTimerStart(state->txbuf[idx].timer, 0);
                      xSemaphoreGive(buf_mutex);
              xQueueSend(qToSwitch, &pkt, 0);
              printf("Packet sent to switch: from=%d to=%d seq=%ld data=\"%s\"\n",
            		  pkt->from, pkt->to, (long)pkt->seq, pkt->data);
             // printf("DEBUG: Sendand buffer after creatr timer before sema \n");
               xSemaphoreTake(stats_mutex, portMAX_DELAY);
              // printf("DEBUG: Sendand buffer after creatr timer aftere sema \n");
               total_transmissions++;
               xSemaphoreGive(stats_mutex);


              // printf("DEBUG: Sendand buffer end \n");
           }


    static void SenderTimerCallback(TimerHandle_t xTimer) {
        SenderState *state = (SenderState *)pvTimerGetTimerID(xTimer);

            	xTimerStop(xTimer, 0); xTimerDelete(xTimer, 0);
        int min_ms = 100, max_ms = 200;
               int r_ms = (rand() % (max_ms - min_ms + 1)) + min_ms;

               TimerHandle_t tgen = xTimerCreate(
                         "SenderTimer",
                         pdMS_TO_TICKS(r_ms),
             			pdFALSE,
                         (void *)state,
                         SenderTimerCallback
                     );
               xTimerStart(tgen, 0);

        printf("DEBUG: SenderTimerCallback fired for Sender %ld\n", (long)state->myId);

        xSemaphoreTake(buf_mutex, portMAX_DELAY);
         printf("DEBUG: SenderTimerCallback after sema\n");
         bool found3 = false, found4 = false;
          for (int i = 0; i < TX_BUFFER_SIZE; ++i) {
              if (state->txbuf[i].in_use) {
                  if (state->txbuf[i].pkt->to == 3) found3 = true;
                  if (state->txbuf[i].pkt->to == 4) found4 = true;
              }
          }
        if (!found3) {
            int32_t seqToSend = state->seq3;
            Packet *pkt3 = (Packet *)pvPortMalloc(sizeof(Packet));
            if (pkt3) {

            pkt3->isAck = false;
            pkt3->from = state->myId;
            pkt3->to = 3;
            int range = L2_BYTES - L1_BYTES + 1;
            int r = rand() % range;
            pkt3->size = HEADER_SIZE_BYTES + (L1_BYTES + r);
               pkt3->seq = seqToSend;
               set_random_packet_data(pkt3);
               pkt3->retries = 0;
               xSemaphoreGive(buf_mutex);
                           send_and_buffer(state, pkt3);
                           xSemaphoreTake(buf_mutex, portMAX_DELAY);
           }

        }

        if (!found4) {
            int32_t seqToSend = state->seq4;
            Packet *pkt = (Packet *)pvPortMalloc(sizeof(Packet));
            if (pkt) {
            pkt->isAck = false;
            pkt->from = state->myId;
            pkt->to = 4;
            int range = L2_BYTES - L1_BYTES + 1;
            int r = rand() % range;
            pkt->size = HEADER_SIZE_BYTES + (L1_BYTES + r);
                pkt->seq = seqToSend;
                set_random_packet_data(pkt);
                pkt->retries = 0;
                xSemaphoreGive(buf_mutex);
                           send_and_buffer(state, pkt);
                           xSemaphoreTake(buf_mutex, portMAX_DELAY);
            }
        }
        xSemaphoreGive(buf_mutex);
                      printf("DEBUG: SenderTimerCallback  end\n");

    }

    static void SenderTask(void *parameters) {
        SenderState *state = (SenderState *)parameters;
        QueueHandle_t ackQueue = (state->myId == 1) ? qToSender1 : qToSender2;
        Packet *ackPkt = NULL;
        TimerHandle_t tgen = xTimerCreate(
            "SenderTimer",
            pdMS_TO_TICKS(PACKET_GEN_INTERVAL),
			pdFALSE,
            (void *)state,
            SenderTimerCallback
        );
        printf("DEBUG: Sendertask timer\n");
        configASSERT(tgen);
        xTimerStart(tgen, 0);


        for (;;) {
        	if (xQueueReceive(ackQueue, &ackPkt, portMAX_DELAY) == pdPASS) {//printf("DEBUG: Sendertask before semaphore\n");
        		 if (ackPkt == NULL) {
        		                continue;
        		            }
        	    	xSemaphoreTake(buf_mutex, portMAX_DELAY);

        	        for (int i = 0; i < TX_BUFFER_SIZE; ++i) {
        	        	//printf("DEBUG: Sendertask for loop\n");

        	        	printf("DEBUG: Sendertask for loop to=%d \n",
        	        	            		   ackPkt->to);
        	        	 if (state->txbuf[i].in_use && state->txbuf[i].pkt &&
        	        	                    state->txbuf[i].pkt->to == ackPkt->from &&
        	        	                    state->txbuf[i].pkt->seq == ackPkt->seq) {

        	        	                    printf("ACK received for seq %ld from receiver %d\n",
        	        	                           (long)ackPkt->seq, ackPkt->from);
        	        	                    if (ackPkt->from == 3) state->seq3++;
        	        	                                        if (ackPkt->from == 4) state->seq4++;

        	        	                                        txbuf_remove(state, i);
        	        	                                        break;
        	        	                                    }
        	        	                                }
        	        xSemaphoreGive(buf_mutex);
        	                    vPortFree(ackPkt);
        	                }
        	            }
    }



    // ----------------------------------------------------------------------------
    // Switch

    static void SwitchForwardCallback(TimerHandle_t xTimer) {
    	//printf("DEBUG: SwitchForwardCallback fired\n");
        Packet *delayedPkt = (Packet *)pvTimerGetTimerID(xTimer);
        TickType_t now = xTaskGetTickCount();
            printf("SwitchForwardCallback: firing at tick %lu, forwarding seq=%ld to %d\n",
                   (unsigned long)now, (long)delayedPkt->seq, delayedPkt->to);

        xTimerDelete(xTimer, 0);

        QueueHandle_t targetQueue = (delayedPkt->to == 3) ? qToRx3 : qToRx4;
          if (xQueueSend(targetQueue, &delayedPkt, 0) != pdPASS) {
              vPortFree(delayedPkt);  // Free if queue full
              printf("Switch: Failed to forward packet to %d\n", delayedPkt->to);
          }
      }

    static void SwitchTask(void *params) {
        Packet *pkt = NULL;

        for (;;) {
            if (xQueueReceive(qToSwitch_ForACKs, &pkt, 0) == pdPASS) {
                if ((rand() % P_DROP_SCALE) < P_ACK) {
                    printf("Switch: DROPPED ACK seq=%ld\n", pkt->seq);
                    vPortFree(pkt);
                    continue;
                }
                if (pkt->to == 1) {
                    xQueueSend(qToSender1, &pkt, 0);
                    printf("Switch: Forwarded ACK to Sender1 seq=%ld\n", pkt->seq);
                }
                else if (pkt->to == 2) {
                    xQueueSend(qToSender2, &pkt, 0);
                    printf("Switch: Forwarded ACK to Sender2 seq=%ld\n", pkt->seq);
                }
                else {
                    vPortFree(pkt);
                }
                continue;
            }

            if (xQueueReceive(qToSwitch, &pkt,portMAX_DELAY) == pdPASS) {
                if (pkt->isAck) {
                    vPortFree(pkt);
                    continue;
                }
                if ((rand() % P_DROP_SCALE) < P_DROP_PERCENT) {

                    printf("Switch: DROPPED DATA pkt seq=%ld from=%d\n", (long)pkt->seq, pkt->from);
                    xSemaphoreTake(stats_mutex, portMAX_DELAY);
                    total_lost++;
                    xSemaphoreGive(stats_mutex);
                    CheckAndReportStatsAndStop();
                    vPortFree(pkt);
                    continue;
                }

                const uint32_t transmission_delay_ms =
                              (pkt->size * 8000 + C_LINK_CAPACITY - 1) / C_LINK_CAPACITY;
                const TickType_t totalDelayTicks = pdMS_TO_TICKS(PROP_DELAY_MS + transmission_delay_ms);
               // printf("Switch: computed totalDelayTicks = %lu\n", (unsigned long)totalDelayTicks);



                          TimerHandle_t fwdTimer = xTimerCreate(
                                  "FwdTimer",
                                  totalDelayTicks,
                                  pdFALSE,
                                  pkt,
                                  SwitchForwardCallback
                              );
                if (fwdTimer && xTimerStart(fwdTimer, 0) == pdPASS) {
                	printf("fwdtimer created\n");
                           } else {

                               if (fwdTimer) xTimerDelete(fwdTimer, 0);
                               vPortFree(pkt);
                               xSemaphoreTake(stats_mutex, portMAX_DELAY);
                               total_lost++;
                               xSemaphoreGive(stats_mutex);
                           }
            }
        }
    }

    // ----------------------------------------------------------------------------
    // Receiver

    static void ReceiverTask(void *parameters) {
    	int16_t myId = (int16_t)(intptr_t)parameters;
        Packet *pkt = NULL;
        int32_t expectedSeq = 0;
        bool *seenSeq = (myId == 3) ? rx3_seenSeq : rx4_seenSeq;

        for (;;) {
        	printf("DEBUG: Receiver %d waiting for a packet…\n", myId);
            QueueHandle_t inQueue = (myId == 3) ? qToRx3 : qToRx4;
           // printf("DEBUG: Receiver after wating for packet \n");
            if (xQueueReceive(inQueue, &pkt, portMAX_DELAY) == pdPASS) {
                printf("Packet received: receiver %d  from=%d seq=%ld data=\"%s\"\n",
                		pkt->to , pkt->from, (long)pkt->seq, pkt->data);
                bool isDuplicate = false;
                if (pkt->seq >= 0 && pkt->seq < NO_OF_PACKETS) {
                              if (!seenSeq[pkt->seq]) {
                                  seenSeq[pkt->seq] = true;
                                  xSemaphoreTake(stats_mutex, portMAX_DELAY);
                                                      total_received++;
                                                      total_bytes_received += pkt->size;
                                                      xSemaphoreGive(stats_mutex);
                                                      printf("New packet accepted: seq=%ld\n", (long)pkt->seq);
                                                                    } else {
                                                                        isDuplicate = true;
                                                                        printf("Duplicate packet detected: seq=%ld\n", (long)pkt->seq);
                                                                    }
                                                                }
                //printf("DEBUG: Receiver before malloc \n");
                Packet *ackPkt = (Packet *)pvPortMalloc(sizeof(Packet));
                if (ackPkt) {
                					ackPkt->isAck = true;
                	                ackPkt->from = myId;
                	                ackPkt->to = pkt->from;
                	                ackPkt->seq = pkt->seq;
                	                ackPkt->size = K;
                	                ackPkt->retries = 0;
                  //  printf("DEBUG: Receiver after malloc \n");
                	                if (xQueueSend(qToSwitch_ForACKs, &ackPkt, 0) != pdPASS) {
                	                                  vPortFree(ackPkt);
                	                              }
                	                              printf("ACK sent for seq=%ld to sender %d\n", (long)pkt->seq, pkt->from);
                	                          }
                CheckAndReportStatsAndStop();
                vPortFree(pkt);

            }
           // printf("DEBUG: Receiver end \n");
        }
    }

    // ----------------------------------------------------------------------------
    // Setup

    static void setupQueues(void) {
    	 qToSwitch = xQueueCreate(QUEUE_SIZE, sizeof(Packet *));
    	    qToSwitch_ForACKs = xQueueCreate(QUEUE_SIZE, sizeof(Packet *));
    	    qToRx3 = xQueueCreate(QUEUE_SIZE, sizeof(Packet *));
    	    qToRx4 = xQueueCreate(QUEUE_SIZE, sizeof(Packet *));
    	    qToSender1 = xQueueCreate(QUEUE_SIZE, sizeof(Packet *));
    	    qToSender2 = xQueueCreate(QUEUE_SIZE, sizeof(Packet *));
    	    configASSERT(qToSwitch);
    	    configASSERT(qToSwitch_ForACKs);
    	    configASSERT(qToRx3);
    	    configASSERT(qToRx4);
    	    configASSERT(qToSender1);
    	    configASSERT(qToSender2);
    }

    int main(int argc, char* argv[]) {
      //  srand((unsigned)time(NULL));
        setupQueues();

        stats_mutex = xSemaphoreCreateMutex();
           buf_mutex = xSemaphoreCreateMutex();
           configASSERT(stats_mutex);
           configASSERT(buf_mutex);
        memset(rx3_seenSeq, 0, sizeof(rx3_seenSeq));
        memset(rx4_seenSeq, 0, sizeof(rx4_seenSeq));

        memset(senderStates, 0, sizeof(senderStates));

        senderStates[0].myId = 1;

        senderStates[1].myId = 2;


        xTaskCreate(SenderTask, "Sender1", 2048, &senderStates[0], 1, NULL);
        xTaskCreate(SenderTask, "Sender2", 2048, &senderStates[1], 1, NULL);
        xTaskCreate(ReceiverTask, "Receiver3", 1024, (void*)3, 2, NULL);
        xTaskCreate(ReceiverTask, "Receiver4", 1024, (void*)4, 2, NULL);
        xTaskCreate(SwitchTask, "Switch", 1024, NULL, 1, NULL);

        startTick = xTaskGetTickCount();
        vTaskStartScheduler();

        return 0;
    }

    #pragma GCC diagnostic pop

    // ----------------------------------------------------------------------------
    void vApplicationMallocFailedHook(void) {
        printf("malloc failed\n");
        for (;;) ;
    }

    void vApplicationStackOverflowHook(TaskHandle_t pxTask, char *pcTaskName) {
        (void) pcTaskName;
        (void) pxTask;
        printf("stack overflow\n");
        for (;;) ;
    }

    void vApplicationIdleHook(void) {
        volatile size_t xFreeStackSpace;
        xFreeStackSpace = xPortGetFreeHeapSize();
        if (xFreeStackSpace > 100) {
            // Heap could be reduced
        }
    }

    void vApplicationTickHook(void) {
    }

    StaticTask_t xIdleTaskTCB CCM_RAM;
    StackType_t uxIdleTaskStack[configMINIMAL_STACK_SIZE] CCM_RAM;

    void vApplicationGetIdleTaskMemory(StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize) {
        *ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
        *ppxIdleTaskStackBuffer = uxIdleTaskStack;
        *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
    }

    static StaticTask_t xTimerTaskTCB CCM_RAM;
    static StackType_t uxTimerTaskStack[configTIMER_TASK_STACK_DEPTH] CCM_RAM;

    void vApplicationGetTimerTaskMemory(StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize) {
        *ppxTimerTaskTCBBuffer = &xTimerTaskTCB;
        *ppxTimerTaskStackBuffer = uxTimerTaskStack;
        *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
    }
