



#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "timers.h"
#include "semphr.h"

#define MAX_INFLIGHT 8
#define MAX_RETRIES 4
#define PACKET_DATA_LEN 32
#define QUEUE_SIZE 20
#define K 40 // ACK size
#define TIMEOUT_PERIOD 150
#define NO_OF_PACKETS 2000

typedef struct {
    int32_t from, to, seq;
    int16_t size, retries;
    bool isAck;
    char data[PACKET_DATA_LEN];
} Packet;

typedef struct {
    Packet *pkt;
    TimerHandle_t timer;
    int retries;
    bool awaiting_ack;
} InflightEntry;

typedef struct {
    int32_t myId;
    int32_t seq3, seq4;
} SenderState;

static InflightEntry inflight[MAX_INFLIGHT];
static QueueHandle_t qToSwitch, qToRx3, qToRx4, qToSwitchForACKs, qToSender1, qToSender2;
static SemaphoreHandle_t stats_mutex;
static SenderState senderStates[2];
static bool rx3_seenSeq[NO_OF_PACKETS], rx4_seenSeq[NO_OF_PACKETS];
static int32_t total_received=0, total_lost=0;
static uint32_t total_bytes_received=0;

const char* message_pool[] = {
    "eyad", "abdelrahman", "second year", "embeded project", "Dr.Khaled Fouad", "cairo university"
};
#define MESSAGE_POOL_SIZE (sizeof(message_pool)/sizeof(message_pool[0]))

void set_random_packet_data(Packet* pkt) {
    int idx = rand() % MESSAGE_POOL_SIZE;
    strncpy(pkt->data, message_pool[idx], PACKET_DATA_LEN-1);
    pkt->data[PACKET_DATA_LEN-1] = '\0';
}

int find_empty_inflight(void) {
    for (int i=0; i<MAX_INFLIGHT; ++i) if (!inflight[i].awaiting_ack) return i;
    return -1;
}
int find_by_seq(int to, int seq) {
    for (int i=0; i<MAX_INFLIGHT; ++i)
        if (inflight[i].awaiting_ack && inflight[i].pkt->to == to && inflight[i].pkt->seq == seq)
            return i;
    return -1;
}

void SenderTimeoutCallback(TimerHandle_t xTimer) {
    int idx = (int)pvTimerGetTimerID(xTimer);
    if (!inflight[idx].awaiting_ack) return;
    inflight[idx].retries++;
    if (inflight[idx].retries > MAX_RETRIES) {
        printf("Sender: max retries, dropping seq %ld\n", (long)inflight[idx].pkt->seq);
        vPortFree(inflight[idx].pkt);
        inflight[idx].awaiting_ack = false;
        xTimerDelete(inflight[idx].timer, 0);
        return;
    }
    printf("Sender: retransmitting seq %ld (retry %d)\n", (long)inflight[idx].pkt->seq, inflight[idx].retries);
    xQueueSend(qToSwitch, &inflight[idx].pkt, 0);
    xTimerStart(inflight[idx].timer, 0);
}

void send_and_buffer(SenderState* state, Packet* pkt) {
    int idx = find_empty_inflight();
    if (idx < 0) { vPortFree(pkt); return; }
    inflight[idx].pkt = pkt;
    inflight[idx].awaiting_ack = true;
    inflight[idx].retries = 0;
    inflight[idx].timer = xTimerCreate("PktTimer", pdMS_TO_TICKS(TIMEOUT_PERIOD), pdFALSE, (void*)idx, SenderTimeoutCallback);
    xQueueSend(qToSwitch, &pkt, 0);
    xTimerStart(inflight[idx].timer, 0);
}

void handle_ack(int from, int seq) {
    int idx = find_by_seq(from, seq);
    if (idx < 0) return;
    inflight[idx].awaiting_ack = false;
    xTimerDelete(inflight[idx].timer, 0);
    vPortFree(inflight[idx].pkt);
}

void SenderTimerCallback(TimerHandle_t xTimer) {
    SenderState* state = (SenderState*)pvTimerGetTimerID(xTimer);
    Packet* pkt = (Packet*)pvPortMalloc(sizeof(Packet));
    pkt->from = state->myId;
    pkt->to = (rand()%2==0) ? 3 : 4;
    pkt->seq = (pkt->to == 3) ? state->seq3++ : state->seq4++;
    pkt->size = 100; // for demo
    pkt->retries = 0;
    pkt->isAck = false;
    set_random_packet_data(pkt);
    send_and_buffer(state, pkt);
    int r_ms = 100 + rand()%100;
    xTimerChangePeriod(xTimer, pdMS_TO_TICKS(r_ms), 0);
}

void SenderTask(void* param) {
    SenderState* state = (SenderState*)param;
    TimerHandle_t timer = xTimerCreate("SenderTimer", pdMS_TO_TICKS(PACKET_GEN_INTERVAL), pdFALSE, (void*)state, SenderTimerCallback);
    xTimerStart(timer, 0);
    Packet* ackPkt = NULL;
    QueueHandle_t myAckQ = (state->myId==1) ? qToSender1 : qToSender2;
    for (;;) {
        if (xQueueReceive(myAckQ, &ackPkt, portMAX_DELAY) == pdPASS) {
            handle_ack(state->myId, ackPkt->seq);
            vPortFree(ackPkt);
        }
    }
}

void SwitchForwardCallback(TimerHandle_t xTimer) {
    Packet* delayedPkt = (Packet*)pvTimerGetTimerID(xTimer);
    if (delayedPkt->to == 3) xQueueSendToBack(qToRx3, &delayedPkt, 0);
    else if (delayedPkt->to == 4) xQueueSendToBack(qToRx4, &delayedPkt, 0);
    xTimerDelete(xTimer, 0);
}

void SwitchTask(void* param) {
    Packet* pkt = NULL;
    for (;;) {
        if (xQueueReceive(qToSwitch, &pkt, portMAX_DELAY) == pdPASS) {
            if (pkt->isAck) {
                if (pkt->to == 1) xQueueSend(qToSender1, &pkt, 0);
                else if (pkt->to == 2) xQueueSend(qToSender2, &pkt, 0);
                else vPortFree(pkt);
                continue;
            }
            if ((rand()%P_DROP_SCALE) < P_DROP_PERCENT) { vPortFree(pkt); continue; }
            TimerHandle_t fwdTimer = xTimerCreate("FwdTimer", pdMS_TO_TICKS(10), pdFALSE, (void*)pkt, SwitchForwardCallback);
            xTimerStart(fwdTimer, 0);
        }
    }
}

void ReceiverTask(void* param) {
    int myId = (int)param;
    Packet* pkt = NULL;
    bool* seenSeq = (myId==3) ? rx3_seenSeq : rx4_seenSeq;
    QueueHandle_t inQ = (myId==3) ? qToRx3 : qToRx4;
    for (;;) {
        if (xQueueReceive(inQ, &pkt, portMAX_DELAY) == pdPASS) {
            if (pkt->seq >= 0 && pkt->seq < NO_OF_PACKETS && !seenSeq[pkt->seq]) {
                seenSeq[pkt->seq] = true;
            }
            Packet* ackPkt = (Packet*)pvPortMalloc(sizeof(Packet));
            ackPkt->isAck = true;
            ackPkt->from = myId;
            ackPkt->to = pkt->from;
            ackPkt->seq = pkt->seq;
            ackPkt->size = K;
            ackPkt->retries = 0;
            xQueueSend(qToSwitch, &ackPkt, 0);
            vPortFree(pkt);
        }
    }
}

void setupQueues(void) {
    qToSwitch = xQueueCreate(QUEUE_SIZE, sizeof(Packet*));
    qToRx3 = xQueueCreate(QUEUE_SIZE, sizeof(Packet*));
    qToRx4 = xQueueCreate(QUEUE_SIZE, sizeof(Packet*));
    qToSwitchForACKs = xQueueCreate(QUEUE_SIZE, sizeof(Packet*));
    qToSender1 = xQueueCreate(QUEUE_SIZE, sizeof(Packet*));
    qToSender2 = xQueueCreate(QUEUE_SIZE, sizeof(Packet*));
}

int main() {
    setupQueues();
    stats_mutex = xSemaphoreCreateMutex();
    senderStates[0].myId=1; senderStates[0].seq3=0; senderStates[0].seq4=0;
    senderStates[1].myId=2; senderStates[1].seq3=0; senderStates[1].seq4=0;
    xTaskCreate(SenderTask, "Sender1", 2048, &senderStates[0], 1, NULL);
    xTaskCreate(SenderTask, "Sender2", 2048, &senderStates[1], 1, NULL);
    xTaskCreate(ReceiverTask, "Receiver3", 2048, (void*)3, 2, NULL);
    xTaskCreate(ReceiverTask, "Receiver4", 2048, (void*)4, 2, NULL);
    xTaskCreate(SwitchTask, "Switch", 2048, NULL, 1, NULL);
    vTaskStartScheduler();
    return 0;
}

// Provide stubs for required FreeRTOS hooks
void vApplicationMallocFailedHook(void) { for(;;); }
void vApplicationStackOverflowHook(TaskHandle_t x, char* y) { for(;;); }
void vApplicationIdleHook(void) {}
void vApplicationTickHook(void) {}
