





#include <stdio.h>
#include <stdlib.h>
#include "diag/trace.h"
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "timers.h"
#include <string.h>
#include "semphr.h"

#define CCM_RAM __attribute__((section(".ccmram")))

#include "led.h"

#define HEADER_SIZE_BYTES   20
#define L1_BYTES            500
#define L2_BYTES            1500
#define PACKET_GEN_INTERVAL 200
#define TIMEOUT_PERIOD      150
#define MAX_RETRIES         4
#define C_LINK_CAPACITY     100000
#define PROP_DELAY_MS       5
#define P_DROP_PERCENT      1
#define P_DROP_SCALE        100
#define P_ACK               1
#define QUEUE_SIZE          200
#define PACKET_DATA_LEN     32
#define NO_OF_PACKETS       2000

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#pragma GCC diagnostic ignored "-Wreturn-type"

typedef struct {
    int32_t from, to;
    int32_t seq;
    int16_t size, retries;
    bool    isAck;
    char    data[PACKET_DATA_LEN];
} Packet;

typedef struct {
    int32_t myId;
    int32_t seq3;
    int32_t seq4;
} SenderState;

static bool rx3_seenSeq[NO_OF_PACKETS];
static bool rx4_seenSeq[NO_OF_PACKETS];
static QueueHandle_t qToSwitch, qToRx3, qToRx4 , qToSwitch_ForACKs , qToSender1 , qToSender2 ;
static SemaphoreHandle_t stats_mutex;

static int32_t total_received = 0;
static int32_t total_lost = 0;
static uint32_t total_bytes_received = 0;
static TickType_t startTick = 0;
static SenderState senderStates[2];

const char* message_pool[] = {
    "eyad",
    "abdelrahman",
    "second year",
    "embeded project",
    "Dr.Khaled Fouad",
    "cairo university"
};
#define MESSAGE_POOL_SIZE (sizeof(message_pool)/sizeof(message_pool[0]))

void set_random_packet_data(Packet* pkt) {
    if (!pkt) return;
    int idx = rand() % MESSAGE_POOL_SIZE;
    strncpy(pkt->data, message_pool[idx], PACKET_DATA_LEN - 1);
    pkt->data[PACKET_DATA_LEN - 1] = '\0';
}

void print_final_stats(void) {
    int32_t total = total_received + total_lost;
    int32_t pct_int = 0, pct_frac = 0;

    if (total > 0) {
        int32_t pct_percent = (10000 * total_lost) / total;
        pct_int = pct_percent / 100;
        pct_frac = pct_percent % 100;
    }

    printf("=== Simulation Complete ===\n");
    printf("Total received packets: %ld\n", (long)total_received);
    printf("Total lost packets: %ld\n", (long)total_lost);
    printf("Loss percentage: %ld.%02ld%%\n", (long)pct_int, (long)pct_frac);

    TickType_t endTick = xTaskGetTickCount();
    TickType_t deltaTicks = endTick - startTick;
    if (deltaTicks == 0) {
        printf("Throughput = 0 bytes/sec (elapsed time = 0 ticks)\n");
        return;
    }
    uint32_t throughput_bps = ((uint32_t)total_bytes_received * (uint32_t)configTICK_RATE_HZ) / (uint32_t)deltaTicks;
    printf("Throughput = %lu bytes/sec\n", (unsigned long)throughput_bps);
    vTaskEndScheduler();
}

void CheckAndReportStatsAndStop(void) {
    static bool reported = false;
    if (reported) return;

    xSemaphoreTake(stats_mutex, portMAX_DELAY);
    int32_t total = total_received + total_lost;
    if (total >= NO_OF_PACKETS) {
        reported = true;
        print_final_stats();
        xSemaphoreGive(stats_mutex);
        vTaskEndScheduler();
    } else {
        xSemaphoreGive(stats_mutex);
    }
}

void SenderTimerCallback(TimerHandle_t xTimer) {
    SenderState *state = (SenderState *)pvTimerGetTimerID(xTimer);
    Packet *pkt = (Packet *)pvPortMalloc(sizeof(Packet));
    if (!pkt) return;

    pkt->from = state->myId;
    pkt->to = (rand() % 2 == 0) ? 3 : 4;
    int range = L2_BYTES - L1_BYTES + 1;
    int r = rand() % range;
    pkt->size = HEADER_SIZE_BYTES + (L1_BYTES + r);

    pkt->retries = 0;
    pkt->isAck = false;
    set_random_packet_data(pkt);

    xSemaphoreTake(stats_mutex, portMAX_DELAY);
    if (pkt->to == 3) {
        pkt->seq = state->seq3++;
    } else {
        pkt->seq = state->seq4++;
    }
    xSemaphoreGive(stats_mutex);

    if (xQueueSend(qToSwitch, &pkt, 0) == pdPASS) {
        printf("Sender: sent to switch: from=%d to=%d seq=%ld data=\"%s\"\n",
            pkt->from, pkt->to, (long)pkt->seq, pkt->data);
    } else {
        printf("Sender: Could not send to switch queue.\n");
        vPortFree(pkt);
    }
    int min_ms = 100, max_ms = 200;
    int range_ms = max_ms - min_ms + 1;
    int r_ms = (rand() % range_ms) + min_ms;
    TickType_t newPeriod = pdMS_TO_TICKS(r_ms);
    xTimerChangePeriod(xTimer, newPeriod, 0);
}

void SenderTask(void *parameters) {
    SenderState *state = (SenderState *)parameters;
    TimerHandle_t timer = xTimerCreate(
        "SenderTimer",
        pdMS_TO_TICKS(PACKET_GEN_INTERVAL),
        pdFALSE,
        (void *)state,
        SenderTimerCallback
    );
    if (timer != NULL) {
        xTimerStart(timer, 0);
    }
    while (1) vTaskDelay(portMAX_DELAY);
}

void SwitchForwardCallback(TimerHandle_t xTimer)
{
    Packet *delayedPkt = (Packet *)pvTimerGetTimerID(xTimer);
    if (delayedPkt->to == 3) {
        xQueueSendToBack(qToRx3, &delayedPkt, 0);
        printf("switch send to %d: \n", delayedPkt->to);
    } else if (delayedPkt->to == 4) {
        xQueueSendToBack(qToRx4, &delayedPkt, 0);
        printf("switch send to %d: \n", delayedPkt->to);
    } else {
        vPortFree(delayedPkt);
        xTimerDelete(xTimer, 0);
        return;
    }
    xTimerDelete(xTimer, 0);
}

void SwitchTask(void *params) {
    Packet *pkt = NULL;
    for (;;) {
        if (xQueueReceive(qToSwitch, &pkt, portMAX_DELAY) == pdPASS) {
            if (pkt->isAck) {
                if ((rand() % P_DROP_SCALE) < P_ACK) {
                    printf("Switch: DROPPED ACK seq=%ld\n", pkt->seq);
                    vPortFree(pkt);
                    continue;
                }
                if (pkt->to == 1) {
                    xQueueSend(qToSender1, &pkt, 0);
                    printf("Switch: Forwarded ACK to Sender1 seq=%ld\n", pkt->seq);
                } else if (pkt->to == 2) {
                    xQueueSend(qToSender2, &pkt, 0);
                    printf("Switch: Forwarded ACK to Sender2 seq=%ld\n", pkt->seq);
                } else {
                    vPortFree(pkt);
                }
                continue;
            }
            if ((rand() % P_DROP_SCALE) < P_DROP_PERCENT) {
                vPortFree(pkt);
                xSemaphoreTake(stats_mutex, portMAX_DELAY);
                total_lost++;
                xSemaphoreGive(stats_mutex);
                CheckAndReportStatsAndStop();
                continue;
            }
            unsigned long numerator = (unsigned long)pkt->size * 8UL * 1000UL;
            unsigned long tx_delay_ms = (numerator + C_LINK_CAPACITY - 1) / C_LINK_CAPACITY;
            unsigned long total_delay_ms = PROP_DELAY_MS + tx_delay_ms;
            TickType_t totalDelayTicks = pdMS_TO_TICKS((int)total_delay_ms);
            TimerHandle_t fwdTimer = xTimerCreate(
                "FwdTimer",
                totalDelayTicks,
                pdFALSE,
                (void *)pkt,
                SwitchForwardCallback
            );
            if (fwdTimer != NULL) {
                xTimerStart(fwdTimer, 0);
            } else {
                vPortFree(pkt);
                xSemaphoreTake(stats_mutex, portMAX_DELAY);
                total_lost++;
                xSemaphoreGive(stats_mutex);
                CheckAndReportStatsAndStop();
            }
        }
    }
}

void ReceiverTask(void *parameters) {
    int32_t myId = (int32_t)parameters;
    Packet *pkt = NULL;
    BaseType_t status;
    int32_t expectedSeq = 0;
    for (;;) {
        if (myId == 3) {
            status = xQueueReceive(qToRx3, &pkt, portMAX_DELAY);
        } else {
            status = xQueueReceive(qToRx4, &pkt, portMAX_DELAY);
        }
        if (status == pdPASS) {
            printf("Packet received: to=%d from=%d seq=%ld data=\"%s\"\n",
                pkt->to, pkt->from, (long)pkt->seq, pkt->data);
            expectedSeq = pkt->seq + 1;
            bool *seenSeq = (myId == 3) ? rx3_seenSeq : rx4_seenSeq;

            // Only mark as seen if in bounds
            if (pkt->seq >= 0 && pkt->seq < NO_OF_PACKETS && !seenSeq[pkt->seq]) {
                seenSeq[pkt->seq] = true;
                xSemaphoreTake(stats_mutex, portMAX_DELAY);
                total_received++;
                total_bytes_received += pkt->size;
                xSemaphoreGive(stats_mutex);
            }

            Packet *ackPkt = (Packet *)pvPortMalloc(sizeof(Packet));
            if (ackPkt != NULL) {
                ackPkt->isAck   = true;
                ackPkt->from    = myId;
                ackPkt->to      = pkt->from;
                ackPkt->seq     = pkt->seq;
                ackPkt->size    = 40;
                ackPkt->retries = 0;
                if (xQueueSend(qToSwitch_ForACKs, &ackPkt, 0) != pdPASS) {
                    vPortFree(ackPkt);
                }
            }
            vPortFree(pkt);
            CheckAndReportStatsAndStop();
        }
    }
}

static void setupQueues(void) {
    qToSwitch = xQueueCreate(QUEUE_SIZE, sizeof(Packet *));
    qToRx3    = xQueueCreate(QUEUE_SIZE, sizeof(Packet *));
    qToRx4    = xQueueCreate(QUEUE_SIZE, sizeof(Packet *));
    qToSwitch_ForACKs   = xQueueCreate(QUEUE_SIZE, sizeof(Packet *));
    qToSender1          = xQueueCreate(QUEUE_SIZE, sizeof(Packet *));
    qToSender2          = xQueueCreate(QUEUE_SIZE, sizeof(Packet *));
}

int main(int argc, char* argv[]) {
    srand((unsigned)time(NULL));
    setupQueues();
    stats_mutex = xSemaphoreCreateMutex();

    senderStates[0].myId = 1;
    senderStates[0].seq3 = 0;
    senderStates[0].seq4 = 0;
    senderStates[1].myId = 2;
    senderStates[1].seq3 = 0;
    senderStates[1].seq4 = 0;

    xTaskCreate(SenderTask, "Sender1", 2048, &senderStates[0], 1, NULL);
    xTaskCreate(SenderTask, "Sender2", 2048, &senderStates[1], 1, NULL);
    xTaskCreate(ReceiverTask, "Receiver3", 2048, (void*)3, 2, NULL);
    xTaskCreate(ReceiverTask, "Receiver4", 2048, (void*)4, 2, NULL);
    xTaskCreate(SwitchTask, "Switch", 2048, NULL, 1, NULL);
    startTick = xTaskGetTickCount();
    vTaskStartScheduler();
    return 0;
}

#pragma GCC diagnostic pop

void vApplicationMallocFailedHook(void) { for(;;); }
void vApplicationStackOverflowHook(TaskHandle_t pxTask, char *pcTaskName) { (void) pcTaskName; (void) pxTask; for(;;); }
void vApplicationIdleHook(void) {
    volatile size_t xFreeStackSpace = xPortGetFreeHeapSize();
    if (xFreeStackSpace > 100) { /* Heap could be reduced */ }
}
void vApplicationTickHook(void) {}

StaticTask_t xIdleTaskTCB CCM_RAM;
StackType_t uxIdleTaskStack[configMINIMAL_STACK_SIZE] CCM_RAM;
void vApplicationGetIdleTaskMemory(StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize) {
    *ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
    *ppxIdleTaskStackBuffer = uxIdleTaskStack;
    *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
}
static StaticTask_t xTimerTaskTCB CCM_RAM;
static StackType_t uxTimerTaskStack[configTIMER_TASK_STACK_DEPTH] CCM_RAM;
void vApplicationGetTimerTaskMemory(StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize) {
    *ppxTimerTaskTCBBuffer = &xTimerTaskTCB;
    *ppxTimerTaskStackBuffer = uxTimerTaskStack;
    *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
}
