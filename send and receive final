








#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include "diag/trace.h"
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "timers.h"
#include <string.h>
#include "semphr.h"

#define CCM_RAM __attribute__((section(".ccmram")))

// ----------------------------------------------------------------------------

#include "led.h"

#define HEADER_SIZE_BYTES   20
#define L1_BYTES            500
#define L2_BYTES            1500
#define K                   40 //ack size
#define PACKET_GEN_INTERVAL 200 // initially
#define TIMEOUT_PERIOD      150
#define MAX_RETRIES         4
#define C_LINK_CAPACITY     100000
#define PROP_DELAY_MS       5
#define P_DROP_PERCENT      1
#define P_DROP_SCALE        100
#define P_ACK               1
#define QUEUE_SIZE          20
#define PACKET_DATA_LEN     32
#define NO_OF_PACKETS       200
#define MAX_INFLIGHT_PACKETS 20
#define N                  8    // Window size: 2,4,8,16

// ----------------------------------------------------------------------------
// Type Definitions

typedef struct {
    int32_t from, to;
    int32_t seq;
    int16_t size, retries;
    bool    isAck;
    char    data[PACKET_DATA_LEN];
} Packet;

typedef struct {
    Packet *pkt;
    TimerHandle_t timer;
    int retries;
    bool awaiting_ack;
    int32_t ownerSenderId;
} InflightPacket;

typedef struct {
    int32_t myId;
    int32_t base3, next3;
    int32_t base4, next4;
} SenderState;

// ----------------------------------------------------------------------------
//  Variables

static bool             rx3_seenSeq[NO_OF_PACKETS];
static bool             rx4_seenSeq[NO_OF_PACKETS];
static InflightPacket   inflight[MAX_INFLIGHT_PACKETS];
static uint32_t         total_transmissions       = 0;
static uint32_t         total_dropped_max_retries = 0;
static QueueHandle_t    qToSwitch, qToRx3, qToRx4, qToSwitch_ForACKs, qToSender1, qToSender2;
static SemaphoreHandle_t stats_mutex;

static int32_t          total_received     = 0;
static int32_t          total_lost         = 0;
static uint32_t         total_bytes_received = 0;
static TickType_t       startTick          = 0;
static SenderState      senderStates[2];

const char* message_pool[] = {
    "eyad",
    "abdelrahman",
    "second year",
    "embeded project",
    "Dr.Khaled Fouad",
    "cairo university"
};
#define MESSAGE_POOL_SIZE (sizeof(message_pool)/sizeof(message_pool[0]))

static int find_empty_inflight_slot(void) {
    for (int i = 0; i < MAX_INFLIGHT_PACKETS; ++i) {
        if (!inflight[i].awaiting_ack) {
            return i;
        }
    }
    return -1;
}

static int find_inflight_by_seq(int32_t from, int32_t seq) {
    for (int i = 0; i < MAX_INFLIGHT_PACKETS; ++i) {
        if (inflight[i].awaiting_ack &&
            inflight[i].ownerSenderId == from &&
            inflight[i].pkt->seq == seq) {
            return i;
        }
    }
    return -1;
}

static void set_random_packet_data(Packet* pkt) {
    if (!pkt) return;
    int idx = rand() % MESSAGE_POOL_SIZE;
    strncpy(pkt->data, message_pool[idx], PACKET_DATA_LEN - 1);
    pkt->data[PACKET_DATA_LEN - 1] = '\0';
}

static void print_final_stats(void) {
    int32_t total = total_received + total_lost;
    int32_t pct_int = 0, pct_frac = 0;

    if (total > 0) {
        int32_t pct_percent = (10000 * total_lost) / total;
        pct_int = pct_percent / 100;
        pct_frac = pct_percent % 100;
    }

    printf("=== Simulation Complete ===\n");
    printf("Total received packets: %ld\n", (long)total_received);
    printf("Total lost packets: %ld\n", (long)total_lost);
    printf("Loss percentage: %ld.%02ld%%\n", (long)pct_int, (long)pct_frac);

    TickType_t endTick = xTaskGetTickCount();
    TickType_t deltaTicks = endTick - startTick;

    if (deltaTicks == 0) {
        printf("Throughput = 0 bytes/sec (elapsed time = 0 ticks)\n");
        return;
    }

    uint32_t throughput_bps = ((uint32_t)total_bytes_received * (uint32_t)configTICK_RATE_HZ) / (uint32_t)deltaTicks;
    printf("Throughput = %lu bytes/sec\n", (unsigned long)throughput_bps);
    uint32_t avg_transmissions_per_packet = 0;
    if (total_received > 0) {
        avg_transmissions_per_packet = total_transmissions / total_received;
    }
    printf("Average number of transmissions per packet: %lu\n", (unsigned long)avg_transmissions_per_packet);
    printf("Packets dropped after exceeding max retries (%d): %lu\n",
        MAX_RETRIES, (unsigned long)total_dropped_max_retries);
    vTaskEndScheduler();
}

static void CheckAndReportStatsAndStop(void) {
    static bool reported = false;
    if (reported) return;

    xSemaphoreTake(stats_mutex, portMAX_DELAY);
    int32_t total = total_received + total_lost;
    xSemaphoreGive(stats_mutex);

    if (total >= NO_OF_PACKETS) {
        reported = true;
        print_final_stats();
        vTaskEndScheduler();
    }
}

// ----------------------------------------------------------------------------
// Sender

static void SenderTimeoutCallback(TimerHandle_t xTimer) {
    int firingIdx = (int)pvTimerGetTimerID(xTimer);
    int32_t fromSender = inflight[firingIdx].pkt->from;
    SenderState *state = (fromSender == 1) ? &senderStates[0] : &senderStates[1];

    xSemaphoreTake(stats_mutex, portMAX_DELAY);

    int32_t windowBase, windowNext;
    int16_t pktTo = inflight[firingIdx].pkt->to;
    if (pktTo == 3) {
        windowBase = state->base3;
        windowNext = state->next3;
    } else {
        windowBase = state->base4;
        windowNext = state->next4;
    }

    for (int32_t seq = windowBase; seq < windowNext; ++seq) {
        int idx2 = find_inflight_by_seq(fromSender, seq);
        if (idx2 < 0) continue;
        if (!inflight[idx2].awaiting_ack) continue;

        inflight[idx2].retries++;
        if (inflight[idx2].retries > MAX_RETRIES) {
            printf("Sender %ld: Seq %ld max retries reached, giving up.\n",
                   (long)fromSender, (long)inflight[idx2].pkt->seq);
            total_dropped_max_retries++;
            xTimerStop(inflight[idx2].timer, 0);
            xTimerDelete(inflight[idx2].timer, 0);
            vPortFree(inflight[idx2].pkt);
            inflight[idx2].awaiting_ack = false;
            continue;
        }

        printf("Sender %ld: Timeout, retransmitting seq %ld (retry %d)\n",
               (long)fromSender,
               (long)inflight[idx2].pkt->seq,
               inflight[idx2].retries);
        total_transmissions++;
        xQueueSend(qToSwitch, &inflight[idx2].pkt, 0);

        if (seq == windowBase) {
            xTimerStop(inflight[idx2].timer, 0);
            xTimerChangePeriod(inflight[idx2].timer, pdMS_TO_TICKS(TIMEOUT_PERIOD), 0);
            xTimerStart(inflight[idx2].timer, 0);
        }
    }

    xSemaphoreGive(stats_mutex);
}

static void send_and_buffer(SenderState *state, Packet *pkt) {
    int idx = find_empty_inflight_slot();
    if (idx < 0) {
        printf("Sender %ld: Inflight full, dropping seq %ld\n",
            (long)pkt->from, (long)pkt->seq);
        vPortFree(pkt);
        return;
    }

    pkt->isAck = false;
    inflight[idx].pkt = pkt;
    inflight[idx].retries = 0;
    inflight[idx].awaiting_ack = true;
    inflight[idx].ownerSenderId = pkt->from;

    inflight[idx].timer = xTimerCreate(
        "PktTimer",
        pdMS_TO_TICKS(TIMEOUT_PERIOD),
        pdFALSE,
        (void *)idx,
        SenderTimeoutCallback
    );
    if (!inflight[idx].timer) {
        vPortFree(pkt);
        return;
    }

    xQueueSend(qToSwitch, &pkt, 0);

    xSemaphoreTake(stats_mutex, portMAX_DELAY);
    total_transmissions++;
    xSemaphoreGive(stats_mutex);

    xTimerStart(inflight[idx].timer, 0);
}

static void handle_ack(SenderState *state, int32_t ack_seq) {
    xSemaphoreTake(stats_mutex, portMAX_DELAY);

    int idx0 = find_inflight_by_seq(state->myId, ack_seq);
    if (idx0 < 0) {
        xSemaphoreGive(stats_mutex);
        return;
    }

    int32_t dest = inflight[idx0].pkt->to;

    if (dest == 3) {
        if (ack_seq >= state->base3) {
            for (int32_t seq = state->base3; seq <= ack_seq; ++seq) {
                int idx2 = find_inflight_by_seq(state->myId, seq);
                if (idx2 < 0) continue;
                xTimerStop(inflight[idx2].timer, 0);
                xTimerDelete(inflight[idx2].timer, 0);
                vPortFree(inflight[idx2].pkt);
                inflight[idx2].awaiting_ack = false;
            }
            state->base3 = ack_seq + 1;
        }
    } else {
        if (ack_seq >= state->base4) {
            for (int32_t seq = state->base4; seq <= ack_seq; ++seq) {
                int idx2 = find_inflight_by_seq(state->myId, seq);
                if (idx2 < 0) continue;
                xTimerStop(inflight[idx2].timer, 0);
                xTimerDelete(inflight[idx2].timer, 0);
                vPortFree(inflight[idx2].pkt);
                inflight[idx2].awaiting_ack = false;
            }
            state->base4 = ack_seq + 1;
        }
    }

    xSemaphoreGive(stats_mutex);
}

static void SenderTimerCallback(TimerHandle_t xTimer) {
    SenderState *state = (SenderState *)pvTimerGetTimerID(xTimer);

    xSemaphoreTake(stats_mutex, portMAX_DELAY);

    if (state->next3 < state->base3 + N) {
        int32_t seqToSend = state->next3++;
        xSemaphoreGive(stats_mutex);

        Packet *pkt = (Packet *)pvPortMalloc(sizeof(Packet));
        if (!pkt) return;
        pkt->isAck = false;
        pkt->from = state->myId;
        pkt->to = 3;
        int range = L2_BYTES - L1_BYTES + 1;
        int r = rand() % range;
        pkt->size = HEADER_SIZE_BYTES + (L1_BYTES + r);
        pkt->seq = seqToSend;
        set_random_packet_data(pkt);
        pkt->retries = 0;

        send_and_buffer(state, pkt);
    }
    else if (state->next4 < state->base4 + N) {
        int32_t seqToSend = state->next4++;
        xSemaphoreGive(stats_mutex);

        Packet *pkt = (Packet *)pvPortMalloc(sizeof(Packet));
        if (!pkt) return;
        pkt->isAck = false;
        pkt->from = state->myId;
        pkt->to = 4;
        int range = L2_BYTES - L1_BYTES + 1;
        int r = rand() % range;
        pkt->size = HEADER_SIZE_BYTES + (L1_BYTES + r);
        pkt->seq = seqToSend;

        set_random_packet_data(pkt);
        pkt->retries = 0;

        send_and_buffer(state, pkt);
    }
    else {
        xSemaphoreGive(stats_mutex);
    }

    int min_ms = 100, max_ms = 200;
    int r_ms = (rand() % (max_ms - min_ms + 1)) + min_ms;
    TickType_t newPeriod = pdMS_TO_TICKS(r_ms);
    xTimerChangePeriod(xTimer, newPeriod, 0);
}

static void SenderTask(void *parameters) {
    SenderState *state = (SenderState *)parameters;
    QueueHandle_t ackQueue = (state->myId == 1) ? qToSender1 : qToSender2;

    TimerHandle_t tgen = xTimerCreate(
        "SenderTimer",
        pdMS_TO_TICKS(PACKET_GEN_INTERVAL),
        pdFALSE,
        (void *)state,
        SenderTimerCallback
    );
    xTimerStart(tgen, 0);

    Packet *ackPkt = NULL;
    for (;;) {
        if (xQueueReceive(ackQueue, &ackPkt, portMAX_DELAY) == pdPASS) {
            if (ackPkt) {
                handle_ack(state, ackPkt->seq);
                vPortFree(ackPkt);
            }
        }
    }
}

// ----------------------------------------------------------------------------
// Switch

static void SwitchForwardCallback(TimerHandle_t xTimer) {
    Packet *delayedPkt = (Packet *)pvTimerGetTimerID(xTimer);
    xTimerDelete(xTimer, 0);
    if (delayedPkt->to == 3) {
        xQueueSendToBack(qToRx3, &delayedPkt, 0);
        printf("switch send : to=%d from=%d seq=%ld data=\"%s\"\n",
            delayedPkt->to, delayedPkt->from, (long)delayedPkt->seq, delayedPkt->data);
    }
    else if (delayedPkt->to == 4) {
        xQueueSendToBack(qToRx4, &delayedPkt, 0);
        printf("switch send : to=%d from=%d seq=%ld data=\"%s\"\n",
            delayedPkt->to, delayedPkt->from, (long)delayedPkt->seq, delayedPkt->data);
    }
    vPortFree(delayedPkt);
}

static void SwitchTask(void *params) {
    Packet *pkt = NULL;

    for (;;) {
        if (xQueueReceive(qToSwitch_ForACKs, &pkt, 0) == pdPASS) {
            if ((rand() % P_DROP_SCALE) < P_ACK) {
                printf("Switch: DROPPED ACK seq=%ld\n", pkt->seq);
                vPortFree(pkt);
                continue;
            }
            if (pkt->to == 1) {
                xQueueSend(qToSender1, &pkt, 0);
                printf("Switch: Forwarded ACK to Sender1 seq=%ld\n", pkt->seq);
            }
            else if (pkt->to == 2) {
                xQueueSend(qToSender2, &pkt, 0);
                printf("Switch: Forwarded ACK to Sender2 seq=%ld\n", pkt->seq);
            }
            else {
                vPortFree(pkt);
            }
            continue;
        }

        if (xQueueReceive(qToSwitch, &pkt, portMAX_DELAY) == pdPASS) {
            if (pkt->isAck) {
                vPortFree(pkt);
                continue;
            }
            if ((rand() % P_DROP_SCALE) < P_DROP_PERCENT) {
                vPortFree(pkt);
                xSemaphoreTake(stats_mutex, portMAX_DELAY);
                total_lost++;
                xSemaphoreGive(stats_mutex);
                CheckAndReportStatsAndStop();
                continue;
            }

            unsigned long numerator = (unsigned long)pkt->size * 8UL * 1000UL;
            unsigned long tx_delay_ms = (numerator + C_LINK_CAPACITY - 1) / C_LINK_CAPACITY;
            unsigned long total_delay_ms = PROP_DELAY_MS + tx_delay_ms;
            TickType_t totalDelayTicks = pdMS_TO_TICKS((int)total_delay_ms);

            TimerHandle_t fwdTimer = xTimerCreate(
                "FwdTimer",
                totalDelayTicks,
                pdFALSE,
                (void *)pkt,
                SwitchForwardCallback
            );
            if (fwdTimer) {
                xTimerStart(fwdTimer, 0);
            } else {
                vPortFree(pkt);
                xSemaphoreTake(stats_mutex, portMAX_DELAY);
                total_lost++;
                xSemaphoreGive(stats_mutex);
                CheckAndReportStatsAndStop();
            }
        }
    }
}

// ----------------------------------------------------------------------------
// Receiver

static void ReceiverTask(void *parameters) {
    int16_t myId = (int32_t)parameters;
    Packet *pkt = NULL;
    int32_t expectedSeq = 0;
    bool *seenSeq = (myId == 3) ? rx3_seenSeq : rx4_seenSeq;

    for (;;) {
        QueueHandle_t inQueue = (myId == 3) ? qToRx3 : qToRx4;
        if (xQueueReceive(inQueue, &pkt, portMAX_DELAY) == pdPASS) {
            printf("Packet received: from=%d seq=%ld data=\"%s\"\n",
                pkt->from, (long)pkt->seq, pkt->data);

            if (pkt->seq == expectedSeq) {
                // PROPER BOUNDS CHECK
                if (pkt->seq >= 0 && pkt->seq < NO_OF_PACKETS && !seenSeq[pkt->seq]) {
                    seenSeq[pkt->seq] = true;
                    xSemaphoreTake(stats_mutex, portMAX_DELAY);
                    total_received++;
                    total_bytes_received += pkt->size;
                    xSemaphoreGive(stats_mutex);
                }
                expectedSeq++;
            }

            Packet *ackPkt = (Packet *)pvPortMalloc(sizeof(Packet));
            if (ackPkt) {
                ackPkt->isAck = true;
                ackPkt->from = myId;
                ackPkt->to = pkt->from;
                ackPkt->seq = expectedSeq - 1;
                ackPkt->size = K;
                ackPkt->retries = 0;
                if (xQueueSend(qToSwitch_ForACKs, &ackPkt, 0) != pdPASS) {
                    vPortFree(ackPkt);
                }
            }

            vPortFree(pkt);
            CheckAndReportStatsAndStop();
        }
    }
}

// ----------------------------------------------------------------------------
// Setup

static void setupQueues(void) {
    qToSwitch = xQueueCreate(QUEUE_SIZE, sizeof(Packet *));
    qToSwitch_ForACKs = xQueueCreate(QUEUE_SIZE, sizeof(Packet *));
    qToRx3 = xQueueCreate(QUEUE_SIZE, sizeof(Packet *));
    qToRx4 = xQueueCreate(QUEUE_SIZE, sizeof(Packet *));
    qToSender1 = xQueueCreate(QUEUE_SIZE, sizeof(Packet *));
    qToSender2 = xQueueCreate(QUEUE_SIZE, sizeof(Packet *));
    configASSERT(qToSwitch);
    configASSERT(qToSwitch_ForACKs);
    configASSERT(qToRx3);
    configASSERT(qToRx4);
    configASSERT(qToSender1);
    configASSERT(qToSender2);
}

int main(int argc, char* argv[]) {
    srand((unsigned)time(NULL));
    setupQueues();
    stats_mutex = xSemaphoreCreateMutex();
    configASSERT(stats_mutex);

    memset(rx3_seenSeq, 0, sizeof(rx3_seenSeq));
    memset(rx4_seenSeq, 0, sizeof(rx4_seenSeq));
    memset(inflight, 0, sizeof(inflight));
    memset(senderStates, 0, sizeof(senderStates));

    senderStates[0].myId = 1;
    senderStates[0].base3 = senderStates[0].next3 = 0;
    senderStates[0].base4 = senderStates[0].next4 = 0;

    senderStates[1].myId = 2;
    senderStates[1].base3 = senderStates[1].next3 = 0;
    senderStates[1].base4 = senderStates[1].next4 = 0;

    xTaskCreate(SenderTask, "Sender1", 1024, &senderStates[0], 1, NULL);
    xTaskCreate(SenderTask, "Sender2", 1024, &senderStates[1], 1, NULL);
    xTaskCreate(ReceiverTask, "Receiver3", 1024, (void*)3, 2, NULL);
    xTaskCreate(ReceiverTask, "Receiver4", 1024, (void*)4, 2, NULL);
    xTaskCreate(SwitchTask, "Switch", 1024, NULL, 1, NULL);

    startTick = xTaskGetTickCount();
    vTaskStartScheduler();

    return 0;
}

#pragma GCC diagnostic pop

// ----------------------------------------------------------------------------
void vApplicationMallocFailedHook(void) {
    printf("malloc failed\n");
    for (;;) ;
}

void vApplicationStackOverflowHook(TaskHandle_t pxTask, char *pcTaskName) {
    (void) pcTaskName;
    (void) pxTask;
    printf("stack overflow\n");
    for (;;) ;
}

void vApplicationIdleHook(void) {
    volatile size_t xFreeStackSpace;
    xFreeStackSpace = xPortGetFreeHeapSize();
    if (xFreeStackSpace > 100) {
        // Heap could be reduced
    }
}

void vApplicationTickHook(void) {
}

StaticTask_t xIdleTaskTCB CCM_RAM;
StackType_t uxIdleTaskStack[configMINIMAL_STACK_SIZE] CCM_RAM;

void vApplicationGetIdleTaskMemory(StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize) {
    *ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
    *ppxIdleTaskStackBuffer = uxIdleTaskStack;
    *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
}

static StaticTask_t xTimerTaskTCB CCM_RAM;
static StackType_t uxTimerTaskStack[configTIMER_TASK_STACK_DEPTH] CCM_RAM;

void vApplicationGetTimerTaskMemory(StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize) {
    *ppxTimerTaskTCBBuffer = &xTimerTaskTCB;
    *ppxTimerTaskStackBuffer = uxTimerTaskStack;
    *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
}
