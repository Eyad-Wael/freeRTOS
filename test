/*
 * Network Protocol Simulation Framework
 * ELC 2080 - Spring 2025
 * FreeRTOS-based ARQ Protocol Implementation
 * Configurable Parameter Testing Environment
 */

#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "timers.h"
#include "semphr.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdint.h>

/* Network Configuration Parameters */
#define MIN_FRAME_SIZE 500        // Minimum frame length [500,1500] bytes
#define MAX_FRAME_SIZE 1500       // Maximum frame length
#define ACK_FRAME_SIZE 40         // ACK frame size: 40 bytes
#define CHANNEL_BANDWIDTH 100000  // Channel capacity: 100 kbits/sec
#define ACK_LOSS_RATE 10          // ACK loss probability: 0.01 = 1%
#define CHANNEL_DELAY 5           // Propagation delay: 5 msec
#define MAX_RETRY_COUNT 4         // Maximum retransmission attempts
#define COMPLETION_TARGET 2000    // Target packets for completion
#define MAX_SLIDING_WINDOW 16

/* Frame Header Configuration */
#define FRAME_HEADER_SIZE 12      // seq(4) + src(1) + dst(1) + len(2) + crc(4)

/* Memory Management Configuration */
#define FRAME_BUFFER_COUNT 500
#define ACK_BUFFER_COUNT 300
#define TRANSMISSION_BUFFER_COUNT 200

/* Inter-arrival Time Parameters [T1,T2]: [0.1,0.2] seconds */
#define MIN_INTERVAL_MS 100       // T1 = 0.1 sec = 100ms
#define MAX_INTERVAL_MS 200       // T2 = 0.2 sec = 200ms
#define TASK_SLEEP_TIME 10

/* ========================================== */
/* TEST CONFIGURATION PARAMETERS             */
/* Modify these values for different tests:  */
/* ========================================== */

// Protocol mode: 1 = Stop-and-Wait, 2 = Sliding Window
#define TEST_PROTOCOL_MODE 1

// Frame drop rate (per 1000): 10=0.01%, 20=0.02%, 40=0.04%, 80=0.08%
#define TEST_DROP_PROBABILITY 80

// Retransmission timeout in milliseconds: 150, 175, 200, 225
#define TEST_TIMEOUT_VALUE 150

// Sliding window size (ignored for Stop-and-Wait): 2, 4, 8, 16
#define TEST_WINDOW_SIZE 2

/* ========================================== */

/* Protocol Operation Modes */
typedef enum {
    MODE_STOP_WAIT = 1,      // Stop-and-Wait (N=1)
    MODE_SLIDING_WINDOW = 2  // Sliding Window ARQ
} protocol_type_t;

/* Data Frame Structure */
typedef struct {
    uint32_t frame_sequence;
    uint8_t source_node;
    uint8_t destination_node;
    uint16_t frame_size;
    uint32_t error_check;
    uint8_t* data_payload;
    TickType_t creation_time;
    uint8_t allocated;
} data_frame_t;

/* Acknowledgment Frame Structure */
typedef struct {
    uint8_t ack_source;
    uint8_t ack_target;
    uint32_t ack_number;
    TickType_t ack_time;
    uint8_t allocated;
} ack_frame_t;

/* Transmission Control Block */
typedef struct transmission_entry {
    uint32_t frame_sequence;
    uint16_t frame_size;
    uint8_t source_node;
    uint8_t destination_node;
    TimerHandle_t retry_timer;
    uint8_t retry_attempts;
    TickType_t initial_send_time;
    struct transmission_entry* next_entry;
    uint8_t allocated;
} transmission_entry_t;

/* Receiver Sequence Tracking */
typedef struct {
    uint32_t next_expected_from_node1;
    uint32_t next_expected_from_node2;
} sequence_tracker_t;

/* Memory Pool Arrays */
static data_frame_t frame_memory_pool[FRAME_BUFFER_COUNT];
static ack_frame_t ack_memory_pool[ACK_BUFFER_COUNT];
static transmission_entry_t transmission_memory_pool[TRANSMISSION_BUFFER_COUNT];

/* Inter-task Communication Queues */
static QueueHandle_t network_switch_data_queue;
static QueueHandle_t network_switch_ack_queue;
static QueueHandle_t destination3_queue;
static QueueHandle_t destination4_queue;
static QueueHandle_t source1_ack_queue;
static QueueHandle_t source2_ack_queue;

/* Synchronization Primitives */
static SemaphoreHandle_t statistics_lock;
static SemaphoreHandle_t memory_pool_lock;
static SemaphoreHandle_t initialization_barrier;

/* Performance Metrics */
static volatile uint32_t successfully_received_frames = 0;
static volatile uint32_t total_bytes_transferred = 0;
static volatile uint32_t total_frame_transmissions = 0;
static volatile uint32_t frames_lost_max_retries = 0;
static volatile uint32_t frames_dropped_by_network = 0;
static volatile TickType_t test_start_timestamp = 0;
static volatile TickType_t test_completion_timestamp = 0;
static volatile uint8_t simulation_finished = 0;

/* Active Protocol Configuration */
static volatile uint32_t active_drop_rate = TEST_DROP_PROBABILITY;
static volatile uint32_t active_timeout_ms = TEST_TIMEOUT_VALUE;
static volatile protocol_type_t active_protocol = TEST_PROTOCOL_MODE;
static volatile uint8_t sliding_window_size = TEST_WINDOW_SIZE;

/* Source Node Sequence Numbers */
static volatile uint32_t source1_sequence = 0;
static volatile uint32_t source2_sequence = 0;

/* Source Node Transmission State */
static transmission_entry_t* source1_pending_list = NULL;
static transmission_entry_t* source2_pending_list = NULL;
static volatile uint8_t source1_window_usage = 0;
static volatile uint8_t source2_window_usage = 0;
static volatile uint8_t source1_awaiting_ack = 0;
static volatile uint8_t source2_awaiting_ack = 0;

/* Destination Node State */
static sequence_tracker_t destination3_tracker = {0, 0};
static sequence_tracker_t destination4_tracker = {0, 0};

/* Pseudo-Random Number Generator */
static uint32_t random_seed = 54321;

static uint32_t generate_random(void) {
    random_seed = (random_seed * 1664525U + 1013904223U) & 0x7fffffffU;
    return random_seed;
}

static void initialize_random(uint32_t seed) {
    random_seed = seed;
}

/* FreeRTOS System Hooks */
void vApplicationIdleHook(void) {
    static uint32_t idle_count = 0;
    idle_count++;
    if (idle_count % 15000U == 0U) {
        taskYIELD();
    }
}

void vApplicationTickHook(void) {}

void vApplicationMallocFailedHook(void) {
    printf("CRITICAL: Memory allocation failure! Available heap: %u\n", 
           (unsigned int)xPortGetFreeHeapSize());
    taskDISABLE_INTERRUPTS();
    for(;;) {}
}

void vApplicationStackOverflowHook(TaskHandle_t xTask, char *pcTaskName) {
    (void)xTask;
    printf("CRITICAL: Stack overflow detected in task: %s\n", pcTaskName);
    taskDISABLE_INTERRUPTS();
    for(;;) {}
}

/* Memory Pool Initialization */
static void setup_memory_pools(void) {
    for (uint32_t i = 0; i < FRAME_BUFFER_COUNT; i++) {
        frame_memory_pool[i].allocated = 0;
        frame_memory_pool[i].data_payload = NULL;
    }
    for (uint32_t i = 0; i < ACK_BUFFER_COUNT; i++) {
        ack_memory_pool[i].allocated = 0;
    }
    for (uint32_t i = 0; i < TRANSMISSION_BUFFER_COUNT; i++) {
        transmission_memory_pool[i].allocated = 0;
        transmission_memory_pool[i].next_entry = NULL;
        transmission_memory_pool[i].retry_timer = NULL;
    }
}

static uint32_t count_allocated_frames(void) {
    uint32_t count = 0;
    if (xSemaphoreTake(memory_pool_lock, pdMS_TO_TICKS(100)) == pdTRUE) {
        for (uint32_t i = 0; i < FRAME_BUFFER_COUNT; i++) {
            if (frame_memory_pool[i].allocated) count++;
        }
        xSemaphoreGive(memory_pool_lock);
    }
    return count;
}

static data_frame_t* acquire_frame_buffer(void) {
    if (xSemaphoreTake(memory_pool_lock, pdMS_TO_TICKS(100)) == pdTRUE) {
        for (uint32_t i = 0; i < FRAME_BUFFER_COUNT; i++) {
            if (!frame_memory_pool[i].allocated) {
                frame_memory_pool[i].allocated = 1;
                frame_memory_pool[i].data_payload = NULL;
                xSemaphoreGive(memory_pool_lock);
                return &frame_memory_pool[i];
            }
        }
        xSemaphoreGive(memory_pool_lock);
        printf("ERROR: Frame buffer pool exhausted (%u/%u allocated)\n",
               count_allocated_frames(), FRAME_BUFFER_COUNT);
    }
    return NULL;
}

static void release_frame_buffer(data_frame_t* frame) {
    if (frame && xSemaphoreTake(memory_pool_lock, pdMS_TO_TICKS(100)) == pdTRUE) {
        if (frame->data_payload) {
            vPortFree(frame->data_payload);
            frame->data_payload = NULL;
        }
        frame->allocated = 0;
        xSemaphoreGive(memory_pool_lock);
    }
}

static ack_frame_t* acquire_ack_buffer(void) {
    if (xSemaphoreTake(memory_pool_lock, pdMS_TO_TICKS(100)) == pdTRUE) {
        for (uint32_t i = 0; i < ACK_BUFFER_COUNT; i++) {
            if (!ack_memory_pool[i].allocated) {
                ack_memory_pool[i].allocated = 1;
                xSemaphoreGive(memory_pool_lock);
                return &ack_memory_pool[i];
            }
        }
        xSemaphoreGive(memory_pool_lock);
        printf("ERROR: ACK buffer pool exhausted\n");
    }
    return NULL;
}

static void release_ack_buffer(ack_frame_t* ack) {
    if (ack && xSemaphoreTake(memory_pool_lock, pdMS_TO_TICKS(100)) == pdTRUE) {
        ack->allocated = 0;
        xSemaphoreGive(memory_pool_lock);
    }
}

static transmission_entry_t* acquire_transmission_entry(void) {
    if (xSemaphoreTake(memory_pool_lock, pdMS_TO_TICKS(100)) == pdTRUE) {
        for (uint32_t i = 0; i < TRANSMISSION_BUFFER_COUNT; i++) {
            if (!transmission_memory_pool[i].allocated) {
                transmission_memory_pool[i].allocated = 1;
                transmission_memory_pool[i].next_entry = NULL;
                transmission_memory_pool[i].retry_timer = NULL;
                xSemaphoreGive(memory_pool_lock);
                return &transmission_memory_pool[i];
            }
        }
        xSemaphoreGive(memory_pool_lock);
        printf("ERROR: Transmission entry pool exhausted\n");
    }
    return NULL;
}

static void release_transmission_entry(transmission_entry_t* entry) {
    if (entry && xSemaphoreTake(memory_pool_lock, pdMS_TO_TICKS(100)) == pdTRUE) {
        if (entry->retry_timer != NULL) {
            xTimerStop(entry->retry_timer, 0);
            xTimerDelete(entry->retry_timer, 0);
            entry->retry_timer = NULL;
        }
        entry->allocated = 0;
        entry->next_entry = NULL;
        xSemaphoreGive(memory_pool_lock);
    }
}

/* System Cleanup Functions */
static void cleanup_transmission_lists(void) {
    while (source1_pending_list != NULL) {
        transmission_entry_t* to_free = source1_pending_list;
        source1_pending_list = source1_pending_list->next_entry;
        release_transmission_entry(to_free);
    }
    source1_window_usage = 0;

    while (source2_pending_list != NULL) {
        transmission_entry_t* to_free = source2_pending_list;
        source2_pending_list = source2_pending_list->next_entry;
        release_transmission_entry(to_free);
    }
    source2_window_usage = 0;
}

static void flush_all_queues(void) {
    data_frame_t* frame;
    ack_frame_t* ack;

    while (xQueueReceive(network_switch_data_queue, &frame, 0) == pdTRUE) {
        release_frame_buffer(frame);
    }
    while (xQueueReceive(destination3_queue, &frame, 0) == pdTRUE) {
        release_frame_buffer(frame);
    }
    while (xQueueReceive(destination4_queue, &frame, 0) == pdTRUE) {
        release_frame_buffer(frame);
    }
    while (xQueueReceive(network_switch_ack_queue, &ack, 0) == pdTRUE) {
        release_ack_buffer(ack);
    }
    while (xQueueReceive(source1_ack_queue, &ack, 0) == pdTRUE) {
        release_ack_buffer(ack);
    }
    while (xQueueReceive(source2_ack_queue, &ack, 0) == pdTRUE) {
        release_ack_buffer(ack);
    }
}

/* Utility Functions */
static uint32_t random_in_range(uint32_t min_val, uint32_t max_val) {
    if (max_val <= min_val) return min_val;
    return min_val + (generate_random() % (max_val - min_val + 1U));
}

static uint8_t should_drop_frame(uint32_t drop_rate) {
    return (generate_random() % 1000U) < drop_rate;
}

static uint32_t compute_transmission_time_ms(uint16_t frame_size) {
    uint32_t time_ms = ((uint32_t)frame_size * 8U * 1000U) / CHANNEL_BANDWIDTH;
    return (time_ms > 0U) ? time_ms : 1U;
}

static uint32_t compute_crc(uint8_t* data, uint16_t length) {
    uint32_t crc = 0;
    for (uint16_t i = 0; i < length; i++) {
        crc += data[i];
    }
    return crc;
}

/* Frame Construction Functions */
static data_frame_t* construct_data_frame(uint8_t src, uint8_t dst, uint16_t size, uint32_t seq) {
    data_frame_t* frame = acquire_frame_buffer();
    if (frame == NULL) {
        printf("ERROR: Cannot allocate frame buffer for source %u, seq %lu\n", 
               src, (unsigned long)seq);
        return NULL;
    }

    frame->source_node = src;
    frame->destination_node = dst;
    frame->frame_size = size;
    frame->frame_sequence = seq;
    frame->creation_time = xTaskGetTickCount();

    uint16_t payload_bytes = size - FRAME_HEADER_SIZE;
    frame->data_payload = (uint8_t*)pvPortMalloc(payload_bytes);
    if (frame->data_payload == NULL) {
        release_frame_buffer(frame);
        printf("ERROR: Cannot allocate payload (%u bytes) for frame seq %lu\n",
               payload_bytes, (unsigned long)seq);
        return NULL;
    }

    for (uint16_t i = 0; i < payload_bytes; i++) {
        frame->data_payload[i] = (uint8_t)((seq + i) & 0xFFU);
    }

    frame->error_check = compute_crc(frame->data_payload, payload_bytes);
    return frame;
}

static ack_frame_t* construct_ack_frame(uint8_t src, uint8_t dst, uint32_t seq) {
    ack_frame_t* ack = acquire_ack_buffer();
    if (ack) {
        ack->ack_source = src;
        ack->ack_target = dst;
        ack->ack_number = seq;
        ack->ack_time = xTaskGetTickCount();
    } else {
        printf("ERROR: Cannot allocate ACK buffer for seq %lu\n", (unsigned long)seq);
    }
    return ack;
}

/* Transmission List Management */
static void add_to_transmission_list(uint8_t src_id, uint32_t seq, uint16_t size,
                                   uint8_t dst_id, TimerHandle_t timer) {
    transmission_entry_t* entry = acquire_transmission_entry();
    if (entry == NULL) {
        printf("ERROR: Cannot allocate transmission entry for source %u, seq %lu\n",
               src_id, (unsigned long)seq);
        return;
    }

    entry->frame_sequence = seq;
    entry->frame_size = size;
    entry->source_node = src_id;
    entry->destination_node = dst_id;
    entry->retry_timer = timer;
    entry->retry_attempts = 0;
    entry->initial_send_time = xTaskGetTickCount();

    if (src_id == 1U) {
        entry->next_entry = source1_pending_list;
        source1_pending_list = entry;
        source1_window_usage++;
    } else {
        entry->next_entry = source2_pending_list;
        source2_pending_list = entry;
        source2_window_usage++;
    }
}

static void remove_from_transmission_list(uint8_t src_id, uint32_t seq_num) {
    transmission_entry_t** list_head = (src_id == 1U) ? &source1_pending_list : &source2_pending_list;
    volatile uint8_t* window_usage = (src_id == 1U) ? &source1_window_usage : &source2_window_usage;
    volatile uint8_t* awaiting_ack = (src_id == 1U) ? &source1_awaiting_ack : &source2_awaiting_ack;

    transmission_entry_t* current = *list_head;
    transmission_entry_t* previous = NULL;

    while (current != NULL) {
        if (current->frame_sequence == seq_num) {
            if (previous == NULL) {
                *list_head = current->next_entry;
            } else {
                previous->next_entry = current->next_entry;
            }

            release_transmission_entry(current);
            (*window_usage)--;

            if (active_protocol == MODE_STOP_WAIT) {
                *awaiting_ack = 0;
            }
            break;
        }
        previous = current;
        current = current->next_entry;
    }
}

static void remove_acknowledged_frames_sliding(uint8_t src_id, uint32_t ack_seq) {
    transmission_entry_t** list_head = (src_id == 1U) ? &source1_pending_list : &source2_pending_list;
    volatile uint8_t* window_usage = (src_id == 1U) ? &source1_window_usage : &source2_window_usage;

    while (*list_head != NULL && (*list_head)->frame_sequence <= ack_seq) {
        transmission_entry_t* to_remove = *list_head;
        *list_head = (*list_head)->next_entry;
        release_transmission_entry(to_remove);
        (*window_usage)--;
    }
}

/* Timeout Handler */
static void timeout_handler_callback(TimerHandle_t timer) {
    uint32_t timer_identifier = (uint32_t)pvTimerGetTimerID(timer);
    uint8_t src_id = (uint8_t)((timer_identifier >> 24) & 0xFFU);
    uint32_t seq_num = timer_identifier & 0xFFFFFFU;

    transmission_entry_t** list_head = (src_id == 1U) ? &source1_pending_list : &source2_pending_list;
    transmission_entry_t* current = *list_head;

    while (current != NULL) {
        if (current->frame_sequence == seq_num) {
            current->retry_attempts++;

            if (current->retry_attempts >= MAX_RETRY_COUNT) {
                if (xSemaphoreTake(statistics_lock, pdMS_TO_TICKS(100)) == pdTRUE) {
                    frames_lost_max_retries++;
                    printf("DROPPED (max retries): Source %u -> Destination %u, Seq %lu (after %d attempts)\n",
                           (unsigned int)src_id, (unsigned int)current->destination_node,
                           (unsigned long)seq_num, MAX_RETRY_COUNT);
                    xSemaphoreGive(statistics_lock);
                }
                remove_from_transmission_list(src_id, seq_num);
                return;
            }

            printf("RETRANSMITTING: Source %u -> Destination %u, Seq %lu (attempt %u/%d)\n",
                   (unsigned int)src_id, (unsigned int)current->destination_node,
                   (unsigned long)seq_num, (unsigned int)current->retry_attempts + 1, MAX_RETRY_COUNT);

            if (active_protocol == MODE_SLIDING_WINDOW) {
                transmission_entry_t* retrans_current = current;
                uint8_t retrans_counter = 0;

                while (retrans_current != NULL && retrans_counter < sliding_window_size) {
                    data_frame_t* retrans_frame = construct_data_frame(
                        retrans_current->source_node,
                        retrans_current->destination_node,
                        retrans_current->frame_size,
                        retrans_current->frame_sequence
                    );

                    if (retrans_frame) {
                        if (xQueueSend(network_switch_data_queue, &retrans_frame, pdMS_TO_TICKS(100)) == pdTRUE) {
                            if (xSemaphoreTake(statistics_lock, pdMS_TO_TICKS(100)) == pdTRUE) {
                                total_frame_transmissions++;
                                xSemaphoreGive(statistics_lock);
                            }
                        } else {
                            release_frame_buffer(retrans_frame);
                            printf("ERROR: network_switch_data_queue full, retrans seq %lu\n",
                                   (unsigned long)retrans_frame->frame_sequence);
                        }
                    }
                    retrans_current = retrans_current->next_entry;
                    retrans_counter++;
                }
            } else {
                data_frame_t* retrans_frame = construct_data_frame(current->source_node, current->destination_node,
                                                                 current->frame_size, current->frame_sequence);
                if (retrans_frame) {
                    if (xQueueSend(network_switch_data_queue, &retrans_frame, pdMS_TO_TICKS(100)) == pdTRUE) {
                        if (xSemaphoreTake(statistics_lock, pdMS_TO_TICKS(100)) == pdTRUE) {
                            total_frame_transmissions++;
                            xSemaphoreGive(statistics_lock);
                        }
                    } else {
                        release_frame_buffer(retrans_frame);
                        printf("ERROR: network_switch_data_queue full, retrans seq %lu\n",
                               (unsigned long)retrans_frame->frame_sequence);
                    }
                }
            }

            xTimerReset(current->retry_timer, 0);
            break;
        }
        current = current->next_entry;
    }
}

/* Source Node Task */
static void vSourceNodeTask(void* pvParameters) {
    uint8_t src_id = (uint8_t)pvParameters;
    volatile uint32_t* seq_counter = (src_id == 1U) ? &source1_sequence : &source2_sequence;
    QueueHandle_t ack_queue = (src_id == 1U) ? source1_ack_queue : source2_ack_queue;
    volatile uint8_t* window_usage = (src_id == 1U) ? &source1_window_usage : &source2_window_usage;
    volatile uint8_t* awaiting_ack = (src_id == 1U) ? &source1_awaiting_ack : &source2_awaiting_ack;

    TickType_t last_transmission_time = 0;
    ack_frame_t* incoming_ack;

    printf("Source %u task started\n", (unsigned int)src_id);

    xSemaphoreTake(initialization_barrier, portMAX_DELAY);
    xSemaphoreGive(initialization_barrier);
    last_transmission_time = xTaskGetTickCount();

    for (;;) {
        if (simulation_finished) {
            vTaskDelay(pdMS_TO_TICKS(100));
            continue;
        }

        TickType_t current_time = xTaskGetTickCount();

        // Process incoming ACKs
        while (xQueueReceive(ack_queue, &incoming_ack, 0) == pdTRUE) {
            printf("ACK RECEIVED: From Destination %u -> Source %u, Seq %lu\n",
                   (unsigned int)incoming_ack->ack_source,
                   (unsigned int)incoming_ack->ack_target,
                   (unsigned long)incoming_ack->ack_number);

            if (active_protocol == MODE_SLIDING_WINDOW) {
                remove_acknowledged_frames_sliding(src_id, incoming_ack->ack_number);
            } else {
                remove_from_transmission_list(src_id, incoming_ack->ack_number);
            }
            release_ack_buffer(incoming_ack);
        }

        // Determine if transmission is allowed
        uint8_t transmission_allowed = 0;
        if (active_protocol == MODE_STOP_WAIT) {
            transmission_allowed = (*awaiting_ack == 0U) ? 1U : 0U;
        } else {
            transmission_allowed = (*window_usage < sliding_window_size) ? 1U : 0U;
        }

        uint32_t interval_time = random_in_range(MIN_INTERVAL_MS, MAX_INTERVAL_MS);
        if (transmission_allowed && (current_time - last_transmission_time) >= pdMS_TO_TICKS(interval_time)) {
            uint8_t target_destination = (uint8_t)((generate_random() % 2U) + 3U);
            uint16_t frame_length = (uint16_t)random_in_range(MIN_FRAME_SIZE, MAX_FRAME_SIZE);
            uint32_t sequence_number = *seq_counter;

            data_frame_t* new_frame = construct_data_frame(src_id, target_destination, frame_length, sequence_number);
            if (new_frame != NULL) {
                uint32_t timer_identifier = ((uint32_t)src_id << 24) | (sequence_number & 0xFFFFFFU);
                TimerHandle_t timeout_timer = xTimerCreate(
                    "RetryTimer",
                    pdMS_TO_TICKS(active_timeout_ms),
                    pdFALSE,
                    (void*)timer_identifier,
                    timeout_handler_callback
                );

                if (timeout_timer != NULL) {
                    add_to_transmission_list(src_id, sequence_number, frame_length, target_destination, timeout_timer);

                    if (xQueueSend(network_switch_data_queue, &new_frame, pdMS_TO_TICKS(100)) == pdTRUE) {
                        printf("FRAME SENT: Source %u -> Destination %u, Seq %lu, Length %u bytes\n",
                               (unsigned int)src_id, (unsigned int)target_destination,
                               (unsigned long)sequence_number, (unsigned int)frame_length);

                        if (xSemaphoreTake(statistics_lock, pdMS_TO_TICKS(100)) == pdTRUE) {
                            total_frame_transmissions++;
                            xSemaphoreGive(statistics_lock);
                        }

                        xTimerStart(timeout_timer, 0);

                        if (active_protocol == MODE_STOP_WAIT) {
                            *awaiting_ack = 1;
                        }

                        (*seq_counter)++;
                        last_transmission_time = current_time;
                    } else {
                        release_frame_buffer(new_frame);
                        remove_from_transmission_list(src_id, sequence_number);
                        printf("ERROR: network_switch_data_queue full, seq %lu\n",
                               (unsigned long)sequence_number);
                    }
                } else {
                    release_frame_buffer(new_frame);
                    printf("ERROR: Failed to create timer for seq %lu\n", (unsigned long)sequence_number);
                }
            }
        }

        vTaskDelay(pdMS_TO_TICKS(TASK_SLEEP_TIME));
    }
}

/* Network Switch Task */
static void vNetworkSwitchTask(void* pvParameters) {
    (void)pvParameters;
    data_frame_t* incoming_frame;
    ack_frame_t* incoming_ack;

    printf("Network switch task started\n");

    xSemaphoreTake(initialization_barrier, portMAX_DELAY);
    xSemaphoreGive(initialization_barrier);

    for (;;) {
        uint8_t had_activity = 0;

        if (xQueueReceive(network_switch_data_queue, &incoming_frame, pdMS_TO_TICKS(20)) == pdTRUE) {
            had_activity = 1;

            uint32_t transmission_time = compute_transmission_time_ms(incoming_frame->frame_size);
            uint32_t total_delay = CHANNEL_DELAY + transmission_time;
            vTaskDelay(pdMS_TO_TICKS(total_delay));

            if (should_drop_frame(active_drop_rate)) {
                if (xSemaphoreTake(statistics_lock, pdMS_TO_TICKS(100)) == pdTRUE) {
                    frames_dropped_by_network++;
                    xSemaphoreGive(statistics_lock);
                }
                printf("DROPPED (by network): Source %u -> Destination %u, Seq %lu (P_drop=0.%02u%%)\n",
                       (unsigned int)incoming_frame->source_node,
                       (unsigned int)incoming_frame->destination_node,
                       (unsigned long)incoming_frame->frame_sequence,
                       (unsigned int)active_drop_rate/10);
                release_frame_buffer(incoming_frame);
                continue;
            }

            QueueHandle_t destination_queue = (incoming_frame->destination_node == 3U) ?
                                            destination3_queue : destination4_queue;

            if (xQueueSend(destination_queue, &incoming_frame, pdMS_TO_TICKS(100)) != pdTRUE) {
                release_frame_buffer(incoming_frame);
                printf("ERROR: destination%u_queue full, seq %lu\n",
                       (unsigned int)incoming_frame->destination_node,
                       (unsigned long)incoming_frame->frame_sequence);
            }
        }

        if (xQueueReceive(network_switch_ack_queue, &incoming_ack, pdMS_TO_TICKS(10)) == pdTRUE) {
            had_activity = 1;

            uint32_t ack_delay = CHANNEL_DELAY + compute_transmission_time_ms(ACK_FRAME_SIZE);
            vTaskDelay(pdMS_TO_TICKS(ack_delay));

            if (should_drop_frame(ACK_LOSS_RATE)) {
                release_ack_buffer(incoming_ack);
                continue;
            }

            QueueHandle_t ack_destination = (incoming_ack->ack_target == 1U) ?
                                          source1_ack_queue : source2_ack_queue;

            if (xQueueSend(ack_destination, &incoming_ack, pdMS_TO_TICKS(100)) != pdTRUE) {
                release_ack_buffer(incoming_ack);
                printf("ERROR: source%u_ack_queue full, ACK seq %lu\n",
                       (unsigned int)incoming_ack->ack_target,
                       (unsigned long)incoming_ack->ack_number);
            }
        }

        if (!had_activity) {
            vTaskDelay(pdMS_TO_TICKS(TASK_SLEEP_TIME));
        }
    }
}

/* Destination Node Task */
static void vDestinationNodeTask(void* pvParameters) {
    uint8_t dst_id = (uint8_t)pvParameters;
    QueueHandle_t my_queue = (dst_id == 3U) ? destination3_queue : destination4_queue;
    sequence_tracker_t* my_tracker = (dst_id == 3U) ? &destination3_tracker : &destination4_tracker;
    data_frame_t* incoming_frame;

    printf("Destination %u task started\n", (unsigned int)dst_id);

    xSemaphoreTake(initialization_barrier, portMAX_DELAY);
    xSemaphoreGive(initialization_barrier);

    for (;;) {
        if (xQueueReceive(my_queue, &incoming_frame, pdMS_TO_TICKS(100)) == pdTRUE) {
            volatile uint32_t* expected_seq = (incoming_frame->source_node == 1U) ?
                                   &my_tracker->next_expected_from_node1 :
                                   &my_tracker->next_expected_from_node2;

            uint8_t frame_accepted = 0;

            if (active_protocol == MODE_STOP_WAIT || incoming_frame->frame_sequence == *expected_seq) {
                frame_accepted = 1;
                (*expected_seq)++;
            }

            if (frame_accepted) {
                printf("FRAME RECEIVED: Source %u -> Destination %u, Seq %lu, Length %u bytes [ACCEPTED]\n",
                       (unsigned int)incoming_frame->source_node,
                       (unsigned int)dst_id,
                       (unsigned long)incoming_frame->frame_sequence,
                       (unsigned int)incoming_frame->frame_size);

                if (xSemaphoreTake(statistics_lock, pdMS_TO_TICKS(100)) == pdTRUE) {
                    successfully_received_frames++;
                    total_bytes_transferred += incoming_frame->frame_size;

                    if (successfully_received_frames % 100 == 0U) {
                        printf("*** MILESTONE: %lu frames received ***\n",
                               (unsigned long)successfully_received_frames);
                    }

                    if (successfully_received_frames >= COMPLETION_TARGET && test_completion_timestamp == 0U) {
                        test_completion_timestamp = xTaskGetTickCount();
                        printf("*** TARGET: %lu frames received ***\n",
                               (unsigned long)successfully_received_frames);
                    }
                    xSemaphoreGive(statistics_lock);
                }
            } else {
                printf("FRAME RECEIVED: Source %u -> Destination %u, Seq %lu, Length %u bytes [REJECTED - out of sequence]\n",
                       (unsigned int)incoming_frame->source_node,
                       (unsigned int)dst_id,
                       (unsigned long)incoming_frame->frame_sequence,
                       (unsigned int)incoming_frame->frame_size);
            }

            ack_frame_t* ack = construct_ack_frame(dst_id, incoming_frame->source_node,
                                                 incoming_frame->frame_sequence);
            if (ack) {
                if (xQueueSend(network_switch_ack_queue, &ack, pdMS_TO_TICKS(100)) != pdTRUE) {
                    release_ack_buffer(ack);
                    printf("Destination %u: Failed to send ACK seq %lu\n",
                           (unsigned int)dst_id,
                           (unsigned long)incoming_frame->frame_sequence);
                }
            } else {
                printf("Destination %u: Failed to allocate ACK seq %lu\n",
                       (unsigned int)dst_id,
                       (unsigned long)incoming_frame->frame_sequence);
            }

            release_frame_buffer(incoming_frame);
        } else {
            vTaskDelay(pdMS_TO_TICKS(TASK_SLEEP_TIME));
        }
    }
}

/* Performance Monitoring Task */
static void vPerformanceMonitorTask(void* pvParameters) {
    (void)pvParameters;
    const TickType_t monitoring_interval = pdMS_TO_TICKS(2000);

    printf("Performance monitor task started\n");
    xSemaphoreGive(initialization_barrier);

    printf("\n=== NETWORK PROTOCOL SIMULATION FRAMEWORK ===\n");
    printf("=== CONFIGURABLE PARAMETER TESTING ===\n");
    printf("=== TARGET: %d frames ===\n", COMPLETION_TARGET);

    // Display active configuration
    printf("\n*** ACTIVE TEST CONFIGURATION ***\n");
    printf("Protocol: %s\n", active_protocol == MODE_STOP_WAIT ? "Stop-and-Wait" : "Sliding Window");
    printf("P_drop: 0.%02u%%\n", (unsigned int)active_drop_rate / 10);
    printf("Timeout: %u ms\n", (unsigned int)active_timeout_ms);
    if (active_protocol == MODE_SLIDING_WINDOW) {
        printf("Window Size (N): %u\n", (unsigned int)sliding_window_size);
    } else {
        printf("Window Size: 1 (Stop-and-Wait)\n");
    }
    printf("System Parameters: L1=%d, L2=%d, K=%d, C=%d, P_ack=0.01%%, D=%dms\n",
           MIN_FRAME_SIZE, MAX_FRAME_SIZE, ACK_FRAME_SIZE, CHANNEL_BANDWIDTH, CHANNEL_DELAY);
    printf("T1=%dms, T2=%dms, Max_retrans=%d\n", MIN_INTERVAL_MS, MAX_INTERVAL_MS, MAX_RETRY_COUNT);
    printf("*** BEGINNING SIMULATION ***\n\n");

    for (;;) {
        vTaskDelay(monitoring_interval);

        if (xSemaphoreTake(statistics_lock, pdMS_TO_TICKS(100)) == pdTRUE) {
            printf("Progress: %lu/%d frames, %lu transmissions, %lu dropped\n",
                   (unsigned long)successfully_received_frames,
                   COMPLETION_TARGET,
                   (unsigned long)total_frame_transmissions,
                   (unsigned long)frames_lost_max_retries);

            if (successfully_received_frames >= COMPLETION_TARGET && test_completion_timestamp != 0U) {
                TickType_t test_duration_ms = ((test_completion_timestamp - test_start_timestamp) * 1000U) / configTICK_RATE_HZ;
                uint32_t throughput_bps = 0;
                if (test_duration_ms > 0U) {
                    throughput_bps = (total_bytes_transferred * 1000U) / test_duration_ms;
                }

                uint32_t efficiency_x100 = (successfully_received_frames > 0U) ?
                    (total_frame_transmissions * 100U) / successfully_received_frames : 0;

                printf("\n*** SIMULATION COMPLETE ***\n");
                printf("=== FINAL PERFORMANCE METRICS ===\n");
                printf("Protocol: %s\n", active_protocol == MODE_STOP_WAIT ? "Stop-and-Wait" : "Sliding Window");
                printf("P_drop: 0.%02u%%, Timeout: %ums",
                       (unsigned int)active_drop_rate / 10, (unsigned int)active_timeout_ms);
                if (active_protocol == MODE_SLIDING_WINDOW) {
                    printf(", N=%u", (unsigned int)sliding_window_size);
                }
                printf("\nTest Duration: %lu ms\n", (unsigned long)test_duration_ms);
                printf("Throughput: %lu bytes/sec (%.2f kbytes/sec)\n",
                       throughput_bps, throughput_bps / 1000.0);
                printf("Efficiency: %.2f%% (%lu received / %lu transmitted)\n",
                       efficiency_x100 / 100.0,
                       (unsigned long)successfully_received_frames,
                       (unsigned long)total_frame_transmissions);
                printf("Dropped after %d retries: %lu\n",
                       MAX_RETRY_COUNT,
                       (unsigned long)frames_lost_max_retries);
                printf("Dropped by network: %lu\n",
                       (unsigned long)frames_dropped_by_network);
                printf("*** SIMULATION FINISHED ***\n");

                simulation_finished = 1;
                xSemaphoreGive(statistics_lock);

                // Keep task alive but dormant
                for(;;) {
                    vTaskDelay(pdMS_TO_TICKS(10000));
                }
            }
            xSemaphoreGive(statistics_lock);
        }
    }
}

/* Application Entry Point */
int main(void) {
    printf("=== Network Protocol Simulation Framework ===\n");
    printf("ELC 2080 Spring 2025 - RTOS Implementation\n");
    printf("Stop-and-Wait and Sliding Window ARQ Protocols\n");
    printf("Configurable Parameter Testing Environment\n");
    printf("Memory pools: Frames=%u, ACKs=%u, TX Entries=%u\n",
           FRAME_BUFFER_COUNT, ACK_BUFFER_COUNT, TRANSMISSION_BUFFER_COUNT);

    // Initialize memory management
    setup_memory_pools();
    initialize_random(54321);

    // Create inter-task communication queues
    network_switch_data_queue = xQueueCreate(30, sizeof(data_frame_t*));
    network_switch_ack_queue = xQueueCreate(20, sizeof(ack_frame_t*));
    destination3_queue = xQueueCreate(20, sizeof(data_frame_t*));
    destination4_queue = xQueueCreate(20, sizeof(data_frame_t*));
    source1_ack_queue = xQueueCreate(20, sizeof(ack_frame_t*));
    source2_ack_queue = xQueueCreate(20, sizeof(ack_frame_t*));

    // Create synchronization primitives
    statistics_lock = xSemaphoreCreateMutex();
    memory_pool_lock = xSemaphoreCreateMutex();
    initialization_barrier = xSemaphoreCreateBinary();

    // Verify successful creation
    if (!network_switch_data_queue || !network_switch_ack_queue || !destination3_queue ||
        !destination4_queue || !source1_ack_queue || !source2_ack_queue ||
        !statistics_lock || !memory_pool_lock || !initialization_barrier) {
        printf("ERROR: Failed to create RTOS objects\n");
        return -1;
    }

    test_start_timestamp = xTaskGetTickCount();

    // Create application tasks
    static const uint8_t source1_identifier = 1;
    static const uint8_t source2_identifier = 2;
    static const uint8_t destination3_identifier = 3;
    static const uint8_t destination4_identifier = 4;

    if (xTaskCreate(vSourceNodeTask, "Source1", 1024, (void*)source1_identifier, 3, NULL) != pdPASS ||
        xTaskCreate(vSourceNodeTask, "Source2", 1024, (void*)source2_identifier, 3, NULL) != pdPASS ||
        xTaskCreate(vNetworkSwitchTask, "NetworkSwitch", 1024, NULL, 4, NULL) != pdPASS ||
        xTaskCreate(vDestinationNodeTask, "Destination3", 1024, (void*)destination3_identifier, 3, NULL) != pdPASS ||
        xTaskCreate(vDestinationNodeTask, "Destination4", 1024, (void*)destination4_identifier, 3, NULL) != pdPASS ||
        xTaskCreate(vPerformanceMonitorTask, "PerformanceMonitor", 1024, NULL, 2, NULL) != pdPASS) {
        printf("ERROR: Failed to create application tasks\n");
        return -1;
    }

    printf("All tasks created successfully\n");
    printf("Starting FreeRTOS scheduler...\n");

    vTaskStartScheduler();

    printf("ERROR: Scheduler returned unexpectedly\n");
    return -1;
}
