
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include "diag/trace.h"
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "timers.h"
#include <string.h>
#include "semphr.h"

#define CCM_RAM __attribute__((section(".ccmram")))

// ----------------------------------------------------------------------------

#include "led.h"

#define HEADER_SIZE_BYTES   4
#define L1_BYTES            500
#define L2_BYTES            1500
#define K                   40 //ack size
#define PACKET_GEN_INTERVAL 100 // initially
#define TIMEOUT_PERIOD      200
#define MAX_RETRIES         4
#define C_LINK_CAPACITY     100000
#define PROP_DELAY_MS       5
#define P_DROP_PERCENT      1
#define P_DROP_SCALE        100
#define P_ACK               1
#define QUEUE_SIZE          40
#define PACKET_DATA_LEN     20
#define NO_OF_PACKETS       10
#define TX_BUFFER_SIZE 		20


// ----------------------------------------------------------------------------
// Type Definitions

typedef struct {
    int32_t from, to;
    int32_t seq;
    int16_t size, retries;
    bool    isAck;
    char    data[PACKET_DATA_LEN];
} Packet;



typedef struct {
    Packet* pkt;
    TimerHandle_t timer;
    int retries;
    bool in_use;
} TxSlot;



typedef struct {
    int32_t myId;
    int32_t seq3, seq4;
    bool waiting_ack ;
    TxSlot txbuf[TX_BUFFER_SIZE];


} SenderState;

typedef struct { SenderState *state; int slot; } TimerInfo;
// ----------------------------------------------------------------------------
//  Variables

static bool             rx3_seenSeq[NO_OF_PACKETS];
static bool             rx4_seenSeq[NO_OF_PACKETS];
SemaphoreHandle_t buf_mutex;
static uint32_t         total_transmissions       = 0;
static uint32_t         total_dropped_max_retries = 0;
static QueueHandle_t    qToSwitch, qToRx3, qToRx4, qToSwitch_ForACKs, qToSender1, qToSender2;
static SemaphoreHandle_t stats_mutex;
static int32_t          total_received     = 0;
static int32_t          total_lost         = 0;
static uint32_t         total_bytes_received = 0;
static TickType_t       startTick          = 0;
static SenderState      senderStates[2];

const char* message_pool[] = {
    "eyad",

    "second year",
    "embeded project",
    "Dr.Khaled Fouad",
    "cairo university"
};
#define MESSAGE_POOL_SIZE (sizeof(message_pool)/sizeof(message_pool[0]))

int txbuf_find_seq(SenderState *state, int32_t seq) {
    for (int i = 0; i < TX_BUFFER_SIZE; ++i)
        if (state->txbuf[i].in_use && state->txbuf[i].pkt && state->txbuf[i].pkt->seq == seq)
            return i;
    return -1;
}
void txbuf_remove(SenderState *state, int idx) {
    if (state->txbuf[idx].timer) { TimerInfo *info = (TimerInfo *) pvTimerGetTimerID(state->txbuf[idx].timer);
    	xTimerStop(state->txbuf[idx].timer, 0); xTimerDelete(state->txbuf[idx].timer, 0);
    	if (info) vPortFree(info);}
    if (state->txbuf[idx].pkt) { vPortFree(state->txbuf[idx].pkt); }
    state->txbuf[idx].pkt = NULL;
    state->txbuf[idx].timer = NULL;
    state->txbuf[idx].retries = 0;
    state->txbuf[idx].in_use = false;
}

static void set_random_packet_data(Packet* pkt) {
    if (!pkt) return;
    int idx = rand() % MESSAGE_POOL_SIZE;
    strncpy(pkt->data, message_pool[idx], PACKET_DATA_LEN - 1);
    pkt->data[PACKET_DATA_LEN - 1] = '\0';
}

static void print_final_stats(void) {
    int32_t total = total_received + total_lost;
    int32_t pct_int = 0, pct_frac = 0;

    if (total > 0) {
        int32_t pct_percent = (10000 * total_lost) / total;
        pct_int = pct_percent / 100;
        pct_frac = pct_percent % 100;
    }

    printf("=== Simulation Complete ===\n");
    printf("Total received packets: %ld\n", (long)total_received);
    printf("Total lost packets: %ld\n", (long)total_lost);
    printf("Loss percentage: %ld.%02ld%%\n", (long)pct_int, (long)pct_frac);

    TickType_t endTick = xTaskGetTickCount();
    TickType_t deltaTicks = endTick - startTick;

    if (deltaTicks == 0) {
        printf("Throughput = 0 bytes/sec (elapsed time = 0 ticks)\n");
        return;
    }

    uint32_t throughput_bps = ((uint32_t)total_bytes_received * (uint32_t)configTICK_RATE_HZ) / (uint32_t)deltaTicks;
    printf("Throughput = %lu bytes/sec\n", (unsigned long)throughput_bps);
    uint32_t avg_transmissions_per_packet = 0;
    if (total_received > 0) {
        avg_transmissions_per_packet = total_transmissions / total_received;
    }
    printf("Average number of transmissions per packet: %lu\n", (unsigned long)avg_transmissions_per_packet);
    printf("Packets dropped after exceeding max retries (%d): %lu\n",
        MAX_RETRIES, (unsigned long)total_dropped_max_retries);
    vTaskEndScheduler();
}

static void CheckAndReportStatsAndStop(void) {
    static bool reported = false;
    if (reported) return;

    xSemaphoreTake(stats_mutex, portMAX_DELAY);
    int32_t total = total_received + total_lost;
    xSemaphoreGive(stats_mutex);

    if (total >= NO_OF_PACKETS) {
        reported = true;
        print_final_stats();
        vTaskEndScheduler();
    }
}
    // ----------------------------------------------------------------------------
    // Sender

    void SenderRetransmitCallback(TimerHandle_t t) {

    	 printf("DEBUG: SenderRetransmitCallback\n");
    	TimerInfo *info = (TimerInfo *)pvTimerGetTimerID(t);
    	if (!info) {
    	    printf("TimerInfo is NULL in retransmit callback\n");
    	    return;
    	}

    	    SenderState *state = info->state;

     	   QueueHandle_t ackQueue = (state->myId == 1) ? qToSender1 : qToSender2;
     	        Packet *ackPkt = NULL;
     	        if (xQueueReceive(ackQueue, &ackPkt,portMAX_DELAY) == pdPASS) {
     	        if (ackPkt->isAck == true) {
     	    	            	vPortFree(ackPkt);
     	    	            	return;
     	    	            }
     	    	            }
    	    int slot = info->slot;
    	   printf("DEBUG: SenderRetransmitCallback before semaphore\n");
    	    xSemaphoreTake(buf_mutex, portMAX_DELAY);
    	    printf("DEBUG: SenderRetransmitCallback after semaphore\n");
    	    if (!state->txbuf[slot].in_use || !state->txbuf[slot].pkt){
    	    	 printf("DEBUG: SenderRetransmitCallback first if cond\n");
    	    	 xSemaphoreGive(buf_mutex);

    	    	return;}
    	        state->txbuf[slot].retries++;
    	        if (state->txbuf[slot].retries > MAX_RETRIES) {
    	            // Advance sequence to prevent infinite loops
    	            if (state->txbuf[slot].pkt->to == 3) state->seq3++;
    	            if (state->txbuf[slot].pkt->to == 4) state->seq4++;
    	            txbuf_remove(state, slot);


    	            state->waiting_ack = false;
    	            xSemaphoreTake(stats_mutex, portMAX_DELAY);
    	            total_dropped_max_retries++;
    	            total_lost++;
    	            xSemaphoreGive(stats_mutex);
    	            xSemaphoreGive(buf_mutex);
    	          //     printf("DEBUG: SenderRetransmitCallback DROPPED pkt seq=%ld to=%ld, sliding base\n", (long)dropped_seq, (long)dropped_to);
    	            return;
    	        }



        // Retransmit
    	        printf("DEBUG: SenderRetransmitCallback retransmit\n");
    	        xQueueSend(qToSwitch, &state->txbuf[slot].pkt, 0);
    	           xTimerStart(state->txbuf[slot].timer, 0); // restart timer
    	           xSemaphoreGive(buf_mutex);


    }


    static void send_and_buffer(SenderState *state, Packet *pkt) {
    	printf("DEBUG: Sendand buffer\n");

        int idx = -1;
        for (int i = 0; i < TX_BUFFER_SIZE; ++i) {printf("DEBUG: Sendand buffer for\n");
            if (!state->txbuf[i].in_use) {printf("DEBUG: Sendand buffer if \n");
                idx = i;
                break;
            }
        } if (idx < 0) {
            printf("Sender %ld: BUFFER is  full, dropping seq %ld\n",
                (long)pkt->from, (long)pkt->seq);
            vPortFree(pkt);
            return;
        }
        printf("DEBUG: Sendand buffer after for \n");
       // xSemaphoreTake(buf_mutex, portMAX_DELAY);

        pkt->isAck = false;
        state->txbuf[idx].pkt = pkt;
        state->txbuf[idx].retries = 0;
        state->txbuf[idx].in_use = true;
        //xSemaphoreGive(buf_mutex);


        TimerInfo *cbinfo = pvPortMalloc(sizeof(TimerInfo));
        if (!cbinfo) {
            printf("Failed to allocate TimerInfo\n");
            vPortFree(pkt);
            state->txbuf[idx].pkt = NULL;
            state->txbuf[idx].in_use = false;
            return;
        }
           cbinfo->state = state;
           cbinfo->slot = idx;


           state->txbuf[idx].timer = xTimerCreate(
               "PktTimer",
               pdMS_TO_TICKS(TIMEOUT_PERIOD),
               pdTRUE,
               (void *)cbinfo,
               SenderRetransmitCallback
           );


              if (!state->txbuf[idx].timer) {printf("DEBUG: Sendand buffer after creatr timer  if1\n");
                  vPortFree(cbinfo);
                  vPortFree(pkt);
                  state->txbuf[idx].pkt = NULL;
                  state->txbuf[idx].in_use = false;
                  return;
              }
              xQueueSend(qToSwitch, &pkt, 0);
              printf("Packet sent to switch: from=%d seq=%ld data=\"%s\"\n",
                                  pkt->from, (long)pkt->seq, pkt->data);
              printf("DEBUG: Sendand buffer after creatr timer before sema \n");
               xSemaphoreTake(stats_mutex, portMAX_DELAY);
               printf("DEBUG: Sendand buffer after creatr timer aftere sema \n");
               total_transmissions++;
               xSemaphoreGive(stats_mutex);

               xTimerStart(state->txbuf[idx].timer, 0);
               printf("DEBUG: Sendand buffer end \n");
           }


    static void SenderTimerCallback(TimerHandle_t xTimer) {
        SenderState *state = (SenderState *)pvTimerGetTimerID(xTimer);
        printf("DEBUG: SenderTimerCallback fired for Sender %ld\n", (long)state->myId);
        xSemaphoreTake(stats_mutex, portMAX_DELAY);
         printf("DEBUG: SenderTimerCallback after sema\n");
        int found3 = 0;
        for (int i = 0; i < TX_BUFFER_SIZE; ++i) {
            if (state->txbuf[i].in_use && state->txbuf[i].pkt && state->txbuf[i].pkt->to == 3) {
                found3 = 1;
                break;
            }
        }
        if (!found3) {
            int32_t seqToSend = state->seq3;
            Packet *pkt = (Packet *)pvPortMalloc(sizeof(Packet));
            if (!pkt) return;
            pkt->isAck = false;
            pkt->from = state->myId;
            pkt->to = 3;
            int range = L2_BYTES - L1_BYTES + 1;
            int r = rand() % range;
            pkt->size = HEADER_SIZE_BYTES + (L1_BYTES + r);
               pkt->seq = seqToSend;
               set_random_packet_data(pkt);
               pkt->retries = 0;
               xSemaphoreGive(stats_mutex);
               send_and_buffer(state, pkt);
           }


        int found4 = 0;
        for (int i = 0; i < TX_BUFFER_SIZE; ++i) {
            if (state->txbuf[i].in_use && state->txbuf[i].pkt && state->txbuf[i].pkt->to == 4) {
                found4 = 1;
                break;
            }
        }

        if (!found4) {
            int32_t seqToSend = state->seq4;
            Packet *pkt = (Packet *)pvPortMalloc(sizeof(Packet));
            if (!pkt) return;
            pkt->isAck = false;
            pkt->from = state->myId;
            pkt->to = 4;
            int range = L2_BYTES - L1_BYTES + 1;
            int r = rand() % range;
            pkt->size = HEADER_SIZE_BYTES + (L1_BYTES + r);
                pkt->seq = seqToSend;
                set_random_packet_data(pkt);
                pkt->retries = 0;
                xSemaphoreGive(stats_mutex);
                send_and_buffer(state, pkt);
            }

        xSemaphoreGive(stats_mutex);
                      printf("DEBUG: SenderTimerCallback  end\n");
        int min_ms = 100, max_ms = 200;
        int r_ms = (rand() % (max_ms - min_ms + 1)) + min_ms;
        TickType_t newPeriod = pdMS_TO_TICKS(r_ms);
        xTimerChangePeriod(xTimer, newPeriod, 0);
    }

    static void SenderTask(void *parameters) {
        SenderState *state = (SenderState *)parameters;
        QueueHandle_t ackQueue = (state->myId == 1) ? qToSender1 : qToSender2;
        Packet *ackPkt = NULL;
        TimerHandle_t tgen = xTimerCreate(
            "SenderTimer",
            pdMS_TO_TICKS(PACKET_GEN_INTERVAL),
			pdFALSE,
            (void *)state,
            SenderTimerCallback
        );
        printf("DEBUG: Sendertask timer\n");
        configASSERT(tgen);
        xTimerStart(tgen, 0);



        	if (xQueueReceive(ackQueue, &ackPkt, pdMS_TO_TICKS(200)) == pdPASS) {//printf("DEBUG: Sendertask before semaphore\n");
        	    if (ackPkt) {xSemaphoreTake(buf_mutex, portMAX_DELAY);

        	        for (int i = 0; i < TX_BUFFER_SIZE; ++i) {
        	        	printf("DEBUG: Sendertask for loop\n");

        	        	if (state->txbuf[i].in_use && state->txbuf[i].pkt &&
        	        	    state->txbuf[i].pkt->to == ackPkt->from &&
        	        	    state->txbuf[i].pkt->seq == ackPkt->seq)
 {
        	            	  if (state->txbuf[i].timer) {
        	            	                            xTimerStop(state->txbuf[i].timer, 0);



        	            }

        	            printf("DEBUG: Sendertask after for loop\n");
        	            vPortFree(state->txbuf[i].pkt);
        	                                   state->txbuf[i].pkt = NULL;
        	                                   state->txbuf[i].in_use = false;
        	                                   break;
        	        }
        	        }

        	            if (ackPkt->to == state->myId) {
        	                               if (ackPkt->from == 3) state->seq3++;
        	                               if (ackPkt->from == 4) state->seq4++;
        	                           }

        	       xSemaphoreGive(buf_mutex);
        	       vPortFree(ackPkt);
        	        }
                }//printf("DEBUG: Sendertask after fooor loop\n");

            }

    // ----------------------------------------------------------------------------
    // Switch

    static void SwitchForwardCallback(TimerHandle_t xTimer) {
    	//printf("DEBUG: SwitchForwardCallback fired\n");
        Packet *delayedPkt = (Packet *)pvTimerGetTimerID(xTimer);
        TickType_t now = xTaskGetTickCount();
            printf("SwitchForwardCallback: firing at tick %lu, forwarding seq=%ld to %d\n",
                   (unsigned long)now, (long)delayedPkt->seq, delayedPkt->to);

        xTimerDelete(xTimer, 0);
        QueueHandle_t targetQueue = (delayedPkt->to == 3) ? qToRx3 : qToRx4;
          if (xQueueSend(targetQueue, &delayedPkt, 0) != pdPASS) {
              vPortFree(delayedPkt);  // Free if queue full
              printf("Switch: Failed to forward packet to %d\n", delayedPkt->to);
          }
      }

    static void SwitchTask(void *params) {
        Packet *pkt = NULL;

        for (;;) {
            if (xQueueReceive(qToSwitch_ForACKs, &pkt, 0) == pdPASS) {
                if ((rand() % P_DROP_SCALE) < P_ACK) {
                    printf("Switch: DROPPED ACK seq=%ld\n", pkt->seq);
                    vPortFree(pkt);
                    continue;
                }
                if (pkt->to == 1) {
                    xQueueSend(qToSender1, &pkt, 0);
                    printf("Switch: Forwarded ACK to Sender1 seq=%ld\n", pkt->seq);
                }
                else if (pkt->to == 2) {
                    xQueueSend(qToSender2, &pkt, 0);
                    printf("Switch: Forwarded ACK to Sender2 seq=%ld\n", pkt->seq);
                }
                else {
                    vPortFree(pkt);
                }
                continue;
            }

            if (xQueueReceive(qToSwitch, &pkt, portMAX_DELAY) == pdPASS) {
                if (pkt->isAck) {
                    vPortFree(pkt);
                    continue;
                }
                if ((rand() % P_DROP_SCALE) < P_DROP_PERCENT) {

                    printf("Switch: DROPPED DATA pkt seq=%ld from=%d\n", (long)pkt->seq, pkt->from);
                    xSemaphoreTake(stats_mutex, portMAX_DELAY);
                    total_lost++;
                    xSemaphoreGive(stats_mutex);
                    CheckAndReportStatsAndStop();
                    vPortFree(pkt);
                    continue;
                }

                const uint32_t transmission_delay_ms =
                              (pkt->size * 8000 + C_LINK_CAPACITY - 1) / C_LINK_CAPACITY;
                const TickType_t totalDelayTicks = pdMS_TO_TICKS(PROP_DELAY_MS + transmission_delay_ms);
                printf("Switch: computed totalDelayTicks = %lu\n", (unsigned long)totalDelayTicks);



                          TimerHandle_t fwdTimer = xTimerCreate(
                                  "FwdTimer",
                                  totalDelayTicks,
                                  pdFALSE,
                                  pkt,  // Use original packet, no copy needed
                                  SwitchForwardCallback
                              );
                if (fwdTimer && xTimerStart(fwdTimer, 0) == pdPASS) {
                               // Success - packet will be forwarded by callback
                           } else {
                               // Cleanup on failure
                               if (fwdTimer) xTimerDelete(fwdTimer, 0);
                               vPortFree(pkt);
                               xSemaphoreTake(stats_mutex, portMAX_DELAY);
                               total_lost++;
                               xSemaphoreGive(stats_mutex);
                           }
            }
        }
    }

    // ----------------------------------------------------------------------------
    // Receiver

    static void ReceiverTask(void *parameters) {
    	int16_t myId = (int16_t)(intptr_t)parameters;
        Packet *pkt = NULL;
        int32_t expectedSeq = 0;
        bool *seenSeq = (myId == 3) ? rx3_seenSeq : rx4_seenSeq;

        for (;;) {
        	printf("DEBUG: Receiver %d waiting for a packetâ€¦\n", myId);
            QueueHandle_t inQueue = (myId == 3) ? qToRx3 : qToRx4;
            printf("DEBUG: Receiver after wating for packet \n");
            if (xQueueReceive(inQueue, &pkt, pdMS_TO_TICKS(100)) == pdPASS) {
                printf("Packet received: from=%d seq=%ld data=\"%s\"\n",
                    pkt->from, (long)pkt->seq, pkt->data);
                bool isDuplicate = false;
                if (pkt->seq == expectedSeq) {
                	printf("DEBUG: Receiver if1 \n");
                    if (pkt->seq >= 0 && pkt->seq < NO_OF_PACKETS && !seenSeq[pkt->seq]) {
                        seenSeq[pkt->seq] = true;
                        printf("DEBUG: Receiver if \n");
                        xSemaphoreTake(stats_mutex, portMAX_DELAY);
                        total_received++;
                        total_bytes_received += pkt->size;
                        xSemaphoreGive(stats_mutex);
                        expectedSeq++;
                    }
                    else {
                                        isDuplicate = true;
                                    }
                }
                printf("DEBUG: Receiver before malloc \n");
                Packet *ackPkt = (Packet *)pvPortMalloc(sizeof(Packet));
                if (ackPkt) {
                    ackPkt->isAck = true;
                    ackPkt->from = myId;
                    ackPkt->to = pkt->from;
                    ackPkt->seq = pkt->seq;
                    ackPkt->size = K;
                    ackPkt->retries = 0;
                    printf("DEBUG: Receiver after malloc \n");
                    if (xQueueSend(qToSwitch_ForACKs, &ackPkt, 0) != pdPASS) {
                        vPortFree(ackPkt);
                    }
                }

                vPortFree(pkt);
                CheckAndReportStatsAndStop();
            }
            printf("DEBUG: Receiver end \n");
        }
    }

    // ----------------------------------------------------------------------------
    // Setup

    static void setupQueues(void) {
        qToSwitch = xQueueCreate(QUEUE_SIZE, sizeof(Packet *));
        qToSwitch_ForACKs = xQueueCreate(QUEUE_SIZE, sizeof(Packet *));
        qToRx3 = xQueueCreate(QUEUE_SIZE, sizeof(Packet *));
        qToRx4 = xQueueCreate(QUEUE_SIZE, sizeof(Packet *));
        qToSender1 = xQueueCreate(QUEUE_SIZE, sizeof(Packet *));
        qToSender2 = xQueueCreate(QUEUE_SIZE, sizeof(Packet *));
        configASSERT(qToSwitch);
        configASSERT(qToSwitch_ForACKs);
        configASSERT(qToRx3);
        configASSERT(qToRx4);
        configASSERT(qToSender1);
        configASSERT(qToSender2);
    }

    int main(int argc, char* argv[]) {
      //  srand((unsigned)time(NULL));
        setupQueues();

        stats_mutex = xSemaphoreCreateMutex();
        buf_mutex = xSemaphoreCreateMutex();
        configASSERT(stats_mutex);

        memset(rx3_seenSeq, 0, sizeof(rx3_seenSeq));
        memset(rx4_seenSeq, 0, sizeof(rx4_seenSeq));

        memset(senderStates, 0, sizeof(senderStates));

        senderStates[0].myId = 1;

        senderStates[1].myId = 2;


        xTaskCreate(SenderTask, "Sender1", 2048, &senderStates[0], 1, NULL);
        xTaskCreate(SenderTask, "Sender2", 2048, &senderStates[1], 1, NULL);
        xTaskCreate(ReceiverTask, "Receiver3", 1024, (void*)3, 2, NULL);
        xTaskCreate(ReceiverTask, "Receiver4", 1024, (void*)4, 2, NULL);
        xTaskCreate(SwitchTask, "Switch", 1024, NULL, 1, NULL);

        startTick = xTaskGetTickCount();
        vTaskStartScheduler();

        return 0;
    }

    #pragma GCC diagnostic pop

    // ----------------------------------------------------------------------------
    void vApplicationMallocFailedHook(void) {
        printf("malloc failed\n");
        for (;;) ;
    }

    void vApplicationStackOverflowHook(TaskHandle_t pxTask, char *pcTaskName) {
        (void) pcTaskName;
        (void) pxTask;
        printf("stack overflow\n");
        for (;;) ;
    }

    void vApplicationIdleHook(void) {
        volatile size_t xFreeStackSpace;
        xFreeStackSpace = xPortGetFreeHeapSize();
        if (xFreeStackSpace > 120) {
            // Heap could be reduced
        }
    }

    void vApplicationTickHook(void) {
    }

    StaticTask_t xIdleTaskTCB CCM_RAM;
    StackType_t uxIdleTaskStack[configMINIMAL_STACK_SIZE] CCM_RAM;

    void vApplicationGetIdleTaskMemory(StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize) {
        *ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
        *ppxIdleTaskStackBuffer = uxIdleTaskStack;
        *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
    }

    static StaticTask_t xTimerTaskTCB CCM_RAM;
    static StackType_t uxTimerTaskStack[configTIMER_TASK_STACK_DEPTH] CCM_RAM;

    void vApplicationGetTimerTaskMemory(StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize) {
        *ppxTimerTaskTCBBuffer = &xTimerTaskTCB;
        *ppxTimerTaskStackBuffer = uxTimerTaskStack;
        *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
    }
