





#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include "diag/trace.h"
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "timers.h"
#include <string.h>
#include "semphr.h"

#define CCM_RAM __attribute__((section(".ccmram")))

// ----------------------------------------------------------------------------

#include "led.h"

#define HEADER_SIZE_BYTES   200
#define L1_BYTES            500
#define L2_BYTES            1500
#define K                   40 //ack size
#define PACKET_GEN_INTERVAL 100 // initially
#define TIMEOUT_PERIOD      200
#define MAX_RETRIES         4
#define C_LINK_CAPACITY     100000
#define PROP_DELAY_MS       5
#define P_DROP_PERCENT      1
#define P_DROP_SCALE        100
#define P_ACK               1
#define QUEUE_SIZE          20
#define PACKET_DATA_LEN     32
#define NO_OF_PACKETS       200
#define TX_BUFFER_SIZE 		10
#define N                   1    // Window size: 2,4,8,16

// ----------------------------------------------------------------------------
// Type Definitions

typedef struct {
    int32_t from, to;
    int32_t seq;
    int16_t size, retries;
    bool    isAck;
    char    data[PACKET_DATA_LEN];
} Packet;

typedef struct {
    Packet* pkt;
    TimerHandle_t timer;
    int retries;
    bool in_use;
} TxSlot;

typedef struct {
    int32_t myId;
    int32_t seq3, seq4;
    int32_t next3, base3;
    int32_t next4, base4;
    TxSlot txbuf[TX_BUFFER_SIZE];
} SenderState;

typedef struct { 
    SenderState *state; 
    int slot; 
} TimerInfo;

// ----------------------------------------------------------------------------
//  Variables

static bool             rx3_seenSeq[NO_OF_PACKETS];
static bool             rx4_seenSeq[NO_OF_PACKETS];
SemaphoreHandle_t buf_mutex;
static uint32_t         total_transmissions       = 0;
static uint32_t         total_dropped_max_retries = 0;
static QueueHandle_t    qToSwitch, qToRx3, qToRx4, qToSwitch_ForACKs, qToSender1, qToSender2;
static SemaphoreHandle_t stats_mutex;
static int32_t          total_received     = 0;
static int32_t          total_lost         = 0;
static uint32_t         total_bytes_received = 0;
static TickType_t       startTick          = 0;
static SenderState      senderStates[2];

const char* message_pool[] = {
    "eyad",
    "abdelrahman",
    "second year",
    "embeded project",
    "Dr.Khaled Fouad",
    "cairo university"
};
#define MESSAGE_POOL_SIZE (sizeof(message_pool)/sizeof(message_pool[0]))

int txbuf_find_seq(SenderState *state, int32_t seq) {
    for (int i = 0; i < TX_BUFFER_SIZE; ++i)
        if (state->txbuf[i].in_use && state->txbuf[i].pkt && state->txbuf[i].pkt->seq == seq)
            return i;
    return -1;
}

void txbuf_remove(SenderState *state, int idx) {
    if (state->txbuf[idx].timer) { 
        TimerInfo *info = (TimerInfo *) pvTimerGetTimerID(state->txbuf[idx].timer);
    	xTimerStop(state->txbuf[idx].timer, 0); 
        xTimerDelete(state->txbuf[idx].timer, 0);
    	if (info) vPortFree(info);
    }
    if (state->txbuf[idx].pkt) { 
        vPortFree(state->txbuf[idx].pkt); 
    }
    state->txbuf[idx].pkt = NULL;
    state->txbuf[idx].timer = NULL;
    state->txbuf[idx].retries = 0;
    state->txbuf[idx].in_use = false;
}

static void set_random_packet_data(Packet* pkt) {
    if (!pkt) return;
    int idx = rand() % MESSAGE_POOL_SIZE;
    strncpy(pkt->data, message_pool[idx], PACKET_DATA_LEN - 1);
    pkt->data[PACKET_DATA_LEN - 1] = '\0';
}

static void print_final_stats(void) {
    int32_t total = total_received + total_lost;
    int32_t pct_int = 0, pct_frac = 0;

    if (total > 0) {
        int32_t pct_percent = (10000 * total_lost) / total;
        pct_int = pct_percent / 100;
        pct_frac = pct_percent % 100;
    }

    printf("=== Simulation Complete ===\n");
    printf("Total received packets: %ld\n", (long)total_received);
    printf("Total lost packets: %ld\n", (long)total_lost);
    printf("Loss percentage: %ld.%02ld%%\n", (long)pct_int, (long)pct_frac);

    TickType_t endTick = xTaskGetTickCount();
    TickType_t deltaTicks = endTick - startTick;

    if (deltaTicks == 0) {
        printf("Throughput = 0 bytes/sec (elapsed time = 0 ticks)\n");
        return;
    }

    uint32_t throughput_bps = ((uint32_t)total_bytes_received * (uint32_t)configTICK_RATE_HZ) / (uint32_t)deltaTicks;
    printf("Throughput = %lu bytes/sec\n", (unsigned long)throughput_bps);
    uint32_t avg_transmissions_per_packet = 0;
    if (total_received > 0) {
        avg_transmissions_per_packet = total_transmissions / total_received;
    }
    printf("Average number of transmissions per packet: %lu\n", (unsigned long)avg_transmissions_per_packet);
    printf("Packets dropped after exceeding max retries (%d): %lu\n",
        MAX_RETRIES, (unsigned long)total_dropped_max_retries);
    vTaskEndScheduler();
}

static void CheckAndReportStatsAndStop(void) {
    static bool reported = false;
    if (reported) return;

    xSemaphoreTake(stats_mutex, portMAX_DELAY);
    int32_t total = total_received + total_lost;
    xSemaphoreGive(stats_mutex);

    if (total >= NO_OF_PACKETS) {
        reported = true;
        print_final_stats();
        vTaskEndScheduler();
    }
}

// ----------------------------------------------------------------------------
// Sender

void SenderRetransmitCallback(TimerHandle_t t) {
    printf("DEBUG: SenderRetransmitCallback\n");
    TimerInfo *info = (TimerInfo *)pvTimerGetTimerID(t);
    if (!info) {
        printf("TimerInfo is NULL in retransmit callback\n");
        return;
    }
    
    SenderState *state = info->state;
    int slot = info->slot;
    
    xSemaphoreTake(buf_mutex, portMAX_DELAY);
    
    if (!state->txbuf[slot].in_use || !state->txbuf[slot].pkt) {
        printf("DEBUG: SenderRetransmitCallback - slot not in use\n");
        xSemaphoreGive(buf_mutex);
        return;
    }
    
    state->txbuf[slot].retries++;
    if (state->txbuf[slot].retries > MAX_RETRIES) {
        printf("DEBUG: SenderRetransmitCallback - max retries exceeded\n");
        int32_t dropped_seq = state->txbuf[slot].pkt->seq;
        int32_t dropped_to = state->txbuf[slot].pkt->to;
        
        txbuf_remove(state, slot);

        // Update base pointers for Go-Back-N
        if (dropped_to == 3 && state->base3 == dropped_seq) {
            state->base3++;
        }
        if (dropped_to == 4 && state->base4 == dropped_seq) {
            state->base4++;
        }

        xSemaphoreTake(stats_mutex, portMAX_DELAY);
        total_dropped_max_retries++;
        total_lost++;
        xSemaphoreGive(stats_mutex);
        
        printf("DEBUG: DROPPED pkt seq=%ld to=%ld after max retries\n", 
               (long)dropped_seq, (long)dropped_to);

        xSemaphoreGive(buf_mutex);
        CheckAndReportStatsAndStop();
        return;
    }
    
    // Retransmit
    printf("DEBUG: Retransmitting seq=%ld, retry=%d\n", 
           (long)state->txbuf[slot].pkt->seq, state->txbuf[slot].retries);
    
    xQueueSend(qToSwitch, &state->txbuf[slot].pkt, 0);
    xTimerStart(state->txbuf[slot].timer, 0); // restart timer
    
    xSemaphoreGive(buf_mutex);
}

static void send_and_buffer(SenderState *state, Packet *pkt) {
    // Find a free slot in the sender's tx buffer
    int idx = -1;
    for (int i = 0; i < TX_BUFFER_SIZE; ++i) {
        if (!state->txbuf[i].in_use) {
            idx = i;
            break;
        }
    } 
    
    if (idx < 0) {
        printf("Sender %ld: BUFFER is full, dropping seq %ld\n",
            (long)pkt->from, (long)pkt->seq);
        vPortFree(pkt);
        return;
    }

    pkt->isAck = false;
    state->txbuf[idx].pkt = pkt;
    state->txbuf[idx].retries = 0;
    state->txbuf[idx].in_use = true;

    TimerInfo *cbinfo = pvPortMalloc(sizeof(TimerInfo));
    if (!cbinfo) {
        printf("Failed to allocate TimerInfo\n");
        vPortFree(pkt);
        state->txbuf[idx].pkt = NULL;
        state->txbuf[idx].in_use = false;
        return;
    }
    cbinfo->state = state;
    cbinfo->slot = idx;

    // Create timer; pass cbinfo as its ID
    state->txbuf[idx].timer = xTimerCreate(
        "PktTimer",
        pdMS_TO_TICKS(TIMEOUT_PERIOD),
        pdFALSE,
        (void *)cbinfo,
        SenderRetransmitCallback
    );

    if (!state->txbuf[idx].timer) {
        vPortFree(cbinfo);
        vPortFree(pkt);
        state->txbuf[idx].pkt = NULL;
        state->txbuf[idx].in_use = false;
        return;
    }
    
    xQueueSend(qToSwitch, &pkt, 0);
    
    xSemaphoreTake(stats_mutex, portMAX_DELAY);
    total_transmissions++;
    xSemaphoreGive(stats_mutex);

    xTimerStart(state->txbuf[idx].timer, 0);
}

static void SenderTimerCallback(TimerHandle_t xTimer) {
    SenderState *state = (SenderState *)pvTimerGetTimerID(xTimer);
    printf("DEBUG: SenderTimerCallback fired for Sender %ld\n", (long)state->myId);
    
    int sent = 0;
    
    // Check if we can send to receiver 3
    if (state->next3 < state->base3 + N) {
        int32_t seqToSend = state->next3++;
        
        Packet *pkt = (Packet *)pvPortMalloc(sizeof(Packet));
        if (pkt) {
            pkt->isAck = false;
            pkt->from = state->myId;
            pkt->to = 3;
            int range = L2_BYTES - L1_BYTES + 1;
            int r = rand() % range;
            pkt->size = HEADER_SIZE_BYTES + (L1_BYTES + r);
            pkt->seq = seqToSend;
            set_random_packet_data(pkt);
            pkt->retries = 0;
            
            xSemaphoreTake(buf_mutex, portMAX_DELAY);
            send_and_buffer(state, pkt);
            xSemaphoreGive(buf_mutex);
            sent = 1;
        }
    }
    
    // Check if we can send to receiver 4
    if (state->next4 < state->base4 + N) {
        int32_t seqToSend = state->next4++;
        
        Packet *pkt = (Packet *)pvPortMalloc(sizeof(Packet));
        if (pkt) {
            pkt->isAck = false;
            pkt->from = state->myId;
            pkt->to = 4;
            int range = L2_BYTES - L1_BYTES + 1;
            int r = rand() % range;
            pkt->size = HEADER_SIZE_BYTES + (L1_BYTES + r);
            pkt->seq = seqToSend;
            set_random_packet_data(pkt);
            pkt->retries = 0;
            
            xSemaphoreTake(buf_mutex, portMAX_DELAY);
            send_and_buffer(state, pkt);
            xSemaphoreGive(buf_mutex);
            sent = 1;
        }
    }

    // Set random interval for next packet generation
    int min_ms = 100, max_ms = 200;
    int r_ms = (rand() % (max_ms - min_ms + 1)) + min_ms;
    TickType_t newPeriod = pdMS_TO_TICKS(r_ms);
    xTimerChangePeriod(xTimer, newPeriod, 0);
}

static void SenderTask(void *parameters) {
    SenderState *state = (SenderState *)parameters;
    QueueHandle_t ackQueue = (state->myId == 1) ? qToSender1 : qToSender2;

    TimerHandle_t tgen = xTimerCreate(
        "SenderTimer",
        pdMS_TO_TICKS(PACKET_GEN_INTERVAL),
		pdFALSE,
        (void *)state,
        SenderTimerCallback
    );
    configASSERT(tgen);
    xTimerStart(tgen, 0);

    Packet *ackPkt = NULL;
    for (;;) {
    	if (xQueueReceive(ackQueue, &ackPkt, portMAX_DELAY) == pdPASS) {
    	    if (ackPkt) {
                printf("DEBUG: Sender %ld received ACK seq=%ld from=%d\n", 
                       (long)state->myId, (long)ackPkt->seq, ackPkt->from);
                
                xSemaphoreTake(buf_mutex, portMAX_DELAY);
                
                // Remove acknowledged packets (cumulative ACK)
                for (int i = 0; i < TX_BUFFER_SIZE; ++i) {
                    if (state->txbuf[i].in_use && state->txbuf[i].pkt &&
                        state->txbuf[i].pkt->to == ackPkt->from &&
                        state->txbuf[i].pkt->seq <= ackPkt->seq) {
                        printf("DEBUG: Removing ACKed packet seq=%ld\n", 
                               (long)state->txbuf[i].pkt->seq);
                        txbuf_remove(state, i);
                    }
                }

                // Update base pointers
                if (ackPkt->to == state->myId && ackPkt->from == 3) {
                    if (ackPkt->seq >= state->base3) {
                        state->base3 = ackPkt->seq + 1;
                    }
                }
                if (ackPkt->to == state->myId && ackPkt->from == 4) {
                    if (ackPkt->seq >= state->base4) {
                        state->base4 = ackPkt->seq + 1;
                    }
                }
                
                xSemaphoreGive(buf_mutex);
                vPortFree(ackPkt); // Free the ACK packet
            }
        }
    }
}

// ----------------------------------------------------------------------------
// Switch

static void SwitchForwardCallback(TimerHandle_t xTimer) {
	printf("DEBUG: SwitchForwardCallback fired\n");
    Packet *delayedPkt = (Packet *)pvTimerGetTimerID(xTimer);
    xTimerDelete(xTimer, 0);
    
    if (delayedPkt->to == 3) {
        xQueueSendToBack(qToRx3, &delayedPkt, 0);
        printf("switch send : to=%d from=%d seq=%ld data=\"%s\"\n",
            delayedPkt->to, delayedPkt->from, (long)delayedPkt->seq, delayedPkt->data);
    }
    else if (delayedPkt->to == 4) {
        xQueueSendToBack(qToRx4, &delayedPkt, 0);
        printf("switch send : to=%d from=%d seq=%ld data=\"%s\"\n",
            delayedPkt->to, delayedPkt->from, (long)delayedPkt->seq, delayedPkt->data);
    }
}

static void SwitchTask(void *params) {
    Packet *pkt = NULL;

    for (;;) {
        // Handle ACKs first
        if (xQueueReceive(qToSwitch_ForACKs, &pkt, 0) == pdPASS) {
            if ((rand() % P_DROP_SCALE) < P_ACK) {
                printf("Switch: DROPPED ACK seq=%ld\n", (long)pkt->seq);
                vPortFree(pkt);
                continue;
            }
            if (pkt->to == 1) {
                xQueueSend(qToSender1, &pkt, 0);
                printf("Switch: Forwarded ACK to Sender1 seq=%ld\n", (long)pkt->seq);
            }
            else if (pkt->to == 2) {
                xQueueSend(qToSender2, &pkt, 0);
                printf("Switch: Forwarded ACK to Sender2 seq=%ld\n", (long)pkt->seq);
            }
            else {
                vPortFree(pkt);
            }
            continue;
        }

        // Handle data packets
        if (xQueueReceive(qToSwitch, &pkt, portMAX_DELAY) == pdPASS) {
            if (pkt->isAck) {
                vPortFree(pkt);
                continue;
            }
            
            // Check for packet drop
            if ((rand() % P_DROP_SCALE) < P_DROP_PERCENT) {
                printf("Switch: DROPPED DATA pkt seq=%ld from=%d\n", (long)pkt->seq, pkt->from);
                xSemaphoreTake(stats_mutex, portMAX_DELAY);
                total_lost++;
                xSemaphoreGive(stats_mutex);
                CheckAndReportStatsAndStop();
                vPortFree(pkt);
                continue;
            }

            // Calculate delay
            TickType_t totalDelayTicks = pdMS_TO_TICKS(
                PROP_DELAY_MS
                + (((uint32_t)pkt->size * 8000UL + C_LINK_CAPACITY - 1UL) / C_LINK_CAPACITY)
            );

            // Create delayed forwarding timer
            TimerHandle_t fwdTimer = xTimerCreate(
                "FwdTimer",
                totalDelayTicks,
                pdFALSE,
                (void *)pkt,
                SwitchForwardCallback
            );
            
            if (fwdTimer && xTimerStart(fwdTimer, 0) == pdPASS) {
                // Timer created and started successfully
            } else {
                printf("Switch: TIMER CREATE/START FAILED, dropping DATA pkt seq=%ld from=%d\n",
                       (long)pkt->seq, pkt->from);
                xSemaphoreTake(stats_mutex, portMAX_DELAY);
                total_lost++;
                xSemaphoreGive(stats_mutex);
                CheckAndReportStatsAndStop();
                vPortFree(pkt);
            }
        }
    }
}

// ----------------------------------------------------------------------------
// Receiver

static void ReceiverTask(void *parameters) {
    int16_t myId = (int32_t)parameters;
    Packet *pkt = NULL;
    int32_t expectedSeq = 0;
    bool *seenSeq = (myId == 3) ? rx3_seenSeq : rx4_seenSeq;

    for (;;) {
    	printf("DEBUG: Receiver %d waiting for a packet…\n", myId);
        QueueHandle_t inQueue = (myId == 3) ? qToRx3 : qToRx4;
        
        if (xQueueReceive(inQueue, &pkt, portMAX_DELAY) == pdPASS) {
            printf("Packet received: from=%d seq=%ld data=\"%s\" (expected=%ld)\n",
                pkt->from, (long)pkt->seq, pkt->data, (long)expectedSeq);

            // Check if this is the expected packet (in-order delivery)
            if (pkt->seq == expectedSeq) {
                // PROPER BOUNDS CHECK
                if (pkt->seq >= 0 && pkt->seq < NO_OF_PACKETS && !seenSeq[pkt->seq]) {
                    seenSeq[pkt->seq] = true;
                    xSemaphoreTake(stats_mutex, portMAX_DELAY);
                    total_received++;
                    total_bytes_received += pkt->size;
                    xSemaphoreGive(stats_mutex);
                    printf("DEBUG: Receiver %d accepted packet seq=%ld\n", myId, (long)pkt->seq);
                }
                expectedSeq++;
            } else {
                printf("DEBUG: Receiver %d dropping out-of-order packet seq=%ld (expected=%ld)\n", 
                       myId, (long)pkt->seq, (long)expectedSeq);
            }

            // Send ACK for the last correctly received packet
            Packet *ackPkt = (Packet *)pvPortMalloc(sizeof(Packet));
            if (ackPkt) {
                ackPkt->isAck = true;
                ackPkt->from = myId;
                ackPkt->to = pkt->from;
                ackPkt->seq = expectedSeq - 1; // ACK the last correctly received packet
                ackPkt->size = K;
                ackPkt->retries = 0;

                if (xQueueSend(qToSwitch_ForACKs, &ackPkt, 0) != pdPASS) {
                    vPortFree(ackPkt);
                }
                printf("DEBUG: Receiver %d sent ACK seq=%ld to sender %d\n", 
                       myId, (long)(expectedSeq - 1), pkt->from);
            }

            vPortFree(pkt);
            CheckAndReportStatsAndStop();
        }
    }
}

// ----------------------------------------------------------------------------
// Setup

static void setupQueues(void) {
    qToSwitch = xQueueCreate(QUEUE_SIZE, sizeof(Packet *));
    qToSwitch_ForACKs = xQueueCreate(QUEUE_SIZE, sizeof(Packet *));
    qToRx3 = xQueueCreate(QUEUE_SIZE, sizeof(Packet *));
    qToRx4 = xQueueCreate(QUEUE_SIZE, sizeof(Packet *));
    qToSender1 = xQueueCreate(QUEUE_SIZE, sizeof(Packet *));
    qToSender2 = xQueueCreate(QUEUE_SIZE, sizeof(Packet *));
    configASSERT(qToSwitch);
    configASSERT(qToSwitch_ForACKs);
    configASSERT(qToRx3);
    configASSERT(qToRx4);
    configASSERT(qToSender1);
    configASSERT(qToSender2);
}

int main(int argc, char* argv[]) {
    setupQueues();

    stats_mutex = xSemaphoreCreateMutex();
    buf_mutex = xSemaphoreCreateMutex();
    configASSERT(stats_mutex);
    configASSERT(buf_mutex);

    memset(rx3_seenSeq, 0, sizeof(rx3_seenSeq));
    memset(rx4_seenSeq, 0, sizeof(rx4_seenSeq));
    memset(senderStates, 0, sizeof(senderStates));

    senderStates[0].myId = 1;
    senderStates[0].base3 = senderStates[0].next3 = 0;
    senderStates[0].base4 = senderStates[0].next4 = 0;

    senderStates[1].myId = 2;
    senderStates[1].base3 = senderStates[1].next3 = 0;
    senderStates[1].base4 = senderStates[1].next4 = 0;

    xTaskCreate(SenderTask, "Sender1", 1024, &senderStates[0], 1, NULL);
    xTaskCreate(SenderTask, "Sender2", 1024, &senderStates[1], 1, NULL);
    xTaskCreate(ReceiverTask, "Receiver3", 1024, (void*)3, 2, NULL);
    xTaskCreate(ReceiverTask, "Receiver4", 1024, (void*)4, 2, NULL);
    xTaskCreate(SwitchTask, "Switch", 1024, NULL, 1, NULL);

    startTick = xTaskGetTickCount();
    vTaskStartScheduler();

    return 0;
}

#pragma GCC diagnostic pop

// ----------------------------------------------------------------------------
void vApplicationMallocFailedHook(void) {
    printf("malloc failed\n");
    for (;;) ;
}

void vApplicationStackOverflowHook(TaskHandle_t pxTask, char *pcTaskName) {
    (void) pcTaskName;
    (void) pxTask;
    printf("stack overflow\n");
    for (;;) ;
}

void vApplicationIdleHook(void) {
    volatile size_t xFreeStackSpace;
    xFreeStackSpace = xPortGetFreeHeapSize();
    if (xFreeStackSpace > 130) {
        // Heap could be reduced
    }
}

void vApplicationTickHook(void) {
}

StaticTask_t xIdleTaskTCB CCM_RAM;
StackType_t uxIdleTaskStack[configMINIMAL_STACK_SIZE] CCM_RAM;

void vApplicationGetIdleTaskMemory(StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize) {
    *ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
    *ppxIdleTaskStackBuffer = uxIdleTaskStack;
    *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
}

static StaticTask_t xTimerTaskTCB CCM_RAM;
static StackType_t uxTimerTaskStack[configTIMER_TASK_STACK_DEPTH] CCM_RAM;

void vApplicationGetTimerTaskMemory(StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize) {
    *ppxTimerTaskTCBBuffer = &xTimerTaskTCB;
    *ppxTimerTaskStackBuffer = uxTimerTaskStack;
    *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
}
