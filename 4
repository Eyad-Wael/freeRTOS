








#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include "diag/trace.h"
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "timers.h"
#include <string.h>
#include "semphr.h"

#define CCM_RAM __attribute__((section(".ccmram")))

// ----------------------------------------------------------------------------

#include "led.h"


#define T1_MIN_MS       50   
#define T2_MAX_MS       150 
#define HEADER_SIZE_BYTES   16
#define L1_BYTES            500
#define L2_BYTES            1500
#define K                   40 //ack size
#define PACKET_GEN_INTERVAL 100 // initially
#define TIMEOUT_PERIOD      200
#define MAX_RETRIES         4
#define C_LINK_CAPACITY     100000
#define PROP_DELAY_MS       5
#define P_DROP_PERCENT      1
#define P_DROP_SCALE        100
#define P_ACK               1
#define QUEUE_SIZE          40
#define PACKET_DATA_LEN     20
#define NO_OF_PACKETS       100
//#define MAX_NO_OF_PACKETS   100
#define TX_BUFFER_SIZE 		20
#define PACKET_ARR 400
#define ACK_ARR 200
#define BUFFER_ARR 200


// ----------------------------------------------------------------------------
// Type Definitions

typedef struct {
    int32_t from, to;
    int32_t seq;
    int16_t size, retries;
    
    char    data[PACKET_DATA_LEN];
uint8_t in_use;
} Packet;

typedef struct {
    int32_t from, to;
    int32_t seq;
    int16_t size, retries;
    bool    isAck;
uint8_t in_use;
} ACK;


typedef struct {
    Packet* pkt;
    TimerHandle_t timer;
    
} BUFFER;



typedef struct {
    int32_t myId;
    int32_t seq3, seq4;
} SenderState;


// ----------------------------------------------------------------------------
//  Variables
static Packet pkt_arr[PACKET_ARR]=0;
static ACK ack_arr[ACK_ARR]=0;
static BUFFER buf_arr[BUFFER_ARR]=0;
//static bool             rx3_seenSeq[NO_OF_PACKETS];
//static bool             rx4_seenSeq[NO_OF_PACKETS];
static uint32_t         total_transmissions       = 0;
static uint32_t         total_dropped_max_retries = 0;
static QueueHandle_t    qToSwitch, qToRx3, qToRx4, qToSwitch_ForACKs, qToSender1, qToSender2;
static SemaphoreHandle_t stats_mutex;
static SemaphoreHandle_t buf_mutex;
static int32_t          total_received     = 0;
static int32_t          total_lost         = 0;
static uint32_t         total_bytes_received = 0;
static TickType_t       startTick          = 0;
static SenderState      senderStates[2];

const char* message_pool[] = {
    "eyad",
	"abdelrahman",
    "second year",
    "embeded project",
    "Dr.Khaled Fouad",
    "cairo university"
};
#define MESSAGE_POOL_SIZE (sizeof(message_pool)/sizeof(message_pool[0]))

int txbuf_find_seq(SenderState *state, int32_t seq) {
    for (int i = 0; i < BUFFER_ARR; ++i) {
        if (buf_arr[i].in_use && buf_arr[i].pkt && buf_arr[i].pkt->seq == seq) {
            return i;
        }
    }
    return -1;
}

void txbuf_remove(SenderState *state, int idx) {
    if (buf_arr[idx].timer) {
        TimerInfo *info = (TimerInfo *) pvTimerGetTimerID(buf_arr[idx].timer);
        xTimerStop(buf_arr[idx].timer, 0);
        xTimerDelete(buf_arr[idx].timer, 0);
        if (info) vPortFree(info);
    }
    
    if (buf_arr[idx].pkt) {
        buf_arr[idx].pkt->in_use = 0;  // Mark packet as available in pool
        buf_arr[idx].pkt = NULL;
    }
    
    buf_arr[idx].timer = NULL;
    buf_arr[idx].in_use = 0;  // Mark buffer slot as available
}

// Function to get an available packet from the pool
Packet* get_available_packet() {
    for (int i = 0; i < PACKET_ARR; ++i) {
        if (!pkt_arr[i].in_use) {
            pkt_arr[i].in_use = 1;
            return &pkt_arr[i];
        }
    }
    return NULL;  
}

// Function to get an available buffer slot
int get_available_buffer() {
    for (int i = 0; i < BUFFER_ARR; ++i) {
        if (!buf_arr[i].in_use) {
            buf_arr[i].in_use = 1;
            return i;
        }
    }
    return -1;  
}


static void set_random_packet_data(Packet* pkt) {
    if (!pkt) return;
    int idx = rand() % MESSAGE_POOL_SIZE;
    strncpy(pkt->data, message_pool[idx], PACKET_DATA_LEN - 1);
    pkt->data[PACKET_DATA_LEN - 1] = '\0';
}

static void print_final_stats(void) {
    int32_t total = total_received + total_lost;
    int32_t pct_int = 0, pct_frac = 0;

    if (total > 0) {
        int32_t pct_percent = (10000 * total_lost) / total;
        pct_int = pct_percent / 100;
        pct_frac = pct_percent % 100;
    }

    printf("=== Simulation Complete ===\n");
    printf("Total received packets: %ld\n", (long)total_received);
    printf("Total lost packets: %ld\n", (long)total_lost);
    printf("Loss percentage: %ld.%02ld%%\n", (long)pct_int, (long)pct_frac);

    TickType_t endTick = xTaskGetTickCount();
    TickType_t deltaTicks = endTick - startTick;

    if (deltaTicks == 0) {
        printf("Throughput = 0 bytes/sec (elapsed time = 0 ticks)\n");
        return;
    }

    uint32_t throughput_bps = ((uint32_t)total_bytes_received * (uint32_t)configTICK_RATE_HZ) / (uint32_t)deltaTicks;
    printf("Throughput = %lu bytes/sec\n", (unsigned long)throughput_bps);
    
    uint32_t avg_transmissions_per_packet = 0;
    if (total_received > 0) {
        avg_transmissions_per_packet = total_transmissions / total_received;
    }
    printf("Average number of transmissions per packet: %lu\n", (unsigned long)avg_transmissions_per_packet);
    printf("Packets dropped after exceeding max retries (%d): %lu\n",
        MAX_RETRIES, (unsigned long)total_dropped_max_retries);
}

static void CheckAndReportStatsAndStop(void) {
    static bool reported = false;
    if (reported) return;

    xSemaphoreTake(stats_mutex, portMAX_DELAY);
    int32_t total = total_received + total_lost;
    xSemaphoreGive(stats_mutex);

    if (total >= NO_OF_PACKETS) {
        reported = true;
        print_final_stats();
        vTaskEndScheduler();
    }
}

    // ----------------------------------------------------------------------------
    // Sender

 void SenderTimerCallback(TimerHandle_t xTimer) {
    SenderState *state = (SenderState *)pvTimerGetTimerID(xTimer);

    // Get packet from pool instead of malloc
    Packet *pkt = get_available_packet();
    if (!pkt) {
        printf("Sender: No available packets in pool\n");
        return;
    }
    
    pkt->from = state->myId;
    pkt->to = (rand() % 2 == 0) ? 3 : 4;
    
    // Generate random packet length between L1 and L2 (uniformly distributed)
    int packet_length = L1_BYTES + (rand() % (L2_BYTES - L1_BYTES + 1));
    pkt->size = packet_length;
    
    pkt->retries = 0;
    set_random_packet_data(pkt);
    
    xSemaphoreTake(stats_mutex, portMAX_DELAY);
    if (pkt->to == 3) {
        pkt->seq = state->seq3++;
    } else {
        pkt->seq = state->seq4++;
    }
    xSemaphoreGive(stats_mutex);

    if (xQueueSend(qToSwitch, &pkt, 0) == pdPASS) {
        printf("Sender: sent to switch: from=%d to=%d seq=%ld size=%d data=\"%s\"\n", 
               pkt->from, pkt->to, (long)pkt->seq, pkt->size, pkt->data);
    } else {
        printf("Sender: Could not send to switch queue.\n");
        // Return packet to pool instead of vPortFree
        pkt->in_use = 0;
    }
    
    // Generate random interval between T1 and T2 for next packet (uniformly distributed)
    int T1_MIN = 50;  // minimum interval in ms
    int T2_MAX = 150; // maximum interval in ms
    int next_interval = T1_MIN + (rand() % (T2_MAX - T1_MIN + 1));
    xTimerChangePeriod(xTimer, pdMS_TO_TICKS(next_interval), 0);
}

  void SenderTask(void *parameters) {
    SenderState *state = (SenderState *)parameters;
    
    // Generate initial random interval between T1 and T2
    int T1_MIN = 50;  // minimum interval in ms
    int T2_MAX = 150; // maximum interval in ms
    int initial_interval = T1_MIN + (rand() % (T2_MAX - T1_MIN + 1));
    
    TimerHandle_t timer = xTimerCreate(
        "SenderTimer",
        pdMS_TO_TICKS(initial_interval),
        pdFALSE,  // Changed to pdFALSE since we manually set intervals
        (void *)state,
        SenderTimerCallback
    );
    if (timer != NULL) {
        xTimerStart(timer, 0);
    }
    while (1) vTaskDelay(portMAX_DELAY);
}


    // ----------------------------------------------------------------------------
    // Switch

    void SwitchTimerCallback(TimerHandle_t xTimer) {
    xSemaphoreTake(switch_mutex, portMAX_DELAY);
    for (int i = 0; i < switchPktCount; ++i) {
        Packet *pkt = switchBuffer[i];
        int drop_rand = rand() % P_DROP_SCALE;
        if (drop_rand < P_DROP_PERCENT) {
            // Return packet to pool instead of vPortFree
            pkt->in_use = 0;
            xSemaphoreTake(stats_mutex, portMAX_DELAY);
            total_lost++;
            xSemaphoreGive(stats_mutex);
            CheckAndReportStatsAndStop();
            continue;
        }
        if (pkt->to == 3) {
            if (xQueueSendToBack(qToRx3, &pkt, 0) == pdPASS) {
                printf("Switch: forwarded packet to receiver %d (seq=%ld, size=%d)\n", 
                       pkt->to, (long)pkt->seq, pkt->size);
            } else {
                // Queue full, drop packet
                pkt->in_use = 0;
                xSemaphoreTake(stats_mutex, portMAX_DELAY);
                total_lost++;
                xSemaphoreGive(stats_mutex);
                CheckAndReportStatsAndStop();
            }
        } else if (pkt->to == 4) {
            if (xQueueSendToBack(qToRx4, &pkt, 0) == pdPASS) {
                printf("Switch: forwarded packet to receiver %d (seq=%ld, size=%d)\n", 
                       pkt->to, (long)pkt->seq, pkt->size);
            } else {
                // Queue full, drop packet
                pkt->in_use = 0;
                xSemaphoreTake(stats_mutex, portMAX_DELAY);
                total_lost++;
                xSemaphoreGive(stats_mutex);
                CheckAndReportStatsAndStop();
            }
        } else {
            // Invalid destination, drop packet
            pkt->in_use = 0;
        }
    }
    switchPktCount = 0;
    xSemaphoreGive(switch_mutex);
}

void SwitchTask(void *params) {
    Packet *pkt = NULL;
    switch_mutex = xSemaphoreCreateMutex();
    TimerHandle_t timer = xTimerCreate(
        "SwitchTimer",
        pdMS_TO_TICKS(PROP_DELAY_MS),
        pdTRUE, // auto-reload
        NULL,
        SwitchTimerCallback
    );

    if (timer != NULL) xTimerStart(timer, 0);

    while (1) {
        if (xQueueReceive(qToSwitch, &pkt, pdMS_TO_TICKS(50)) == pdPASS) {
            xSemaphoreTake(switch_mutex, portMAX_DELAY);
            if (switchPktCount < QUEUE_SIZE) {
                switchBuffer[switchPktCount++] = pkt;
                printf("Switch: buffered packet from=%d to=%d seq=%ld size=%d\n", 
                       pkt->from, pkt->to, (long)pkt->seq, pkt->size);
            } else {
                // Buffer full, drop packet
                printf("Switch: buffer full, dropping packet from=%d to=%d seq=%ld\n", 
                       pkt->from, pkt->to, (long)pkt->seq);
                pkt->in_use = 0;
                xSemaphoreTake(stats_mutex, portMAX_DELAY);
                total_lost++;
                xSemaphoreGive(stats_mutex);
                CheckAndReportStatsAndStop();
            }
            xSemaphoreGive(switch_mutex);
        }
    }
}


    // ----------------------------------------------------------------------------
    // Receiver

   void ReceiverTask(void *parameters) {
    int32_t myId = (int32_t)parameters;
    Packet *pkt = NULL;
    BaseType_t status;
    int32_t expectedSeq = 0;
    const TickType_t ticksToWait = pdMS_TO_TICKS(TIMEOUT_PERIOD);

    printf("Receiver %d started\n", myId);

    while (1) {
        if (myId == 3) {
            status = xQueueReceive(qToRx3, &pkt, ticksToWait);
        } else {
            status = xQueueReceive(qToRx4, &pkt, ticksToWait);
        }

        if (status == pdPASS) {
            // Check for lost packets (sequence gap)
            if (pkt->seq != expectedSeq) {
                for (int32_t lostSeq = expectedSeq; lostSeq < pkt->seq; ++lostSeq) {
                    printf("Receiver %d: Packet lost - expected seq=%ld\n", myId, (long)lostSeq);
                    xSemaphoreTake(stats_mutex, portMAX_DELAY);
                    total_lost++;
                    xSemaphoreGive(stats_mutex);
                    CheckAndReportStatsAndStop();
                }
            }
            
            printf("Receiver %d: Packet received - from=%d seq=%ld size=%d data=\"%s\"\n", 
                   myId, pkt->from, (long)pkt->seq, pkt->size, pkt->data);
            
            expectedSeq = pkt->seq + 1;
            
            // Update statistics
            xSemaphoreTake(stats_mutex, portMAX_DELAY);
            total_received++;
            total_bytes_received += pkt->size;
            xSemaphoreGive(stats_mutex);
            
            // Return packet to pool
            pkt->in_use = 0;
            
            CheckAndReportStatsAndStop();
        } else {
            // Timeout occurred - assume packet was lost
            printf("Receiver %d: Timeout - expected seq=%ld (packet lost)\n", myId, (long)expectedSeq);
            expectedSeq++;
            xSemaphoreTake(stats_mutex, portMAX_DELAY);
            total_lost++;
            xSemaphoreGive(stats_mutex);
            CheckAndReportStatsAndStop();
        }
    }
}


    // ----------------------------------------------------------------------------
    // Setup

    static void setupQueues(void) {
    	 qToSwitch = xQueueCreate(QUEUE_SIZE, sizeof(Packet *));
    	    qToSwitch_ForACKs = xQueueCreate(QUEUE_SIZE, sizeof(Packet *));
    	    qToRx3 = xQueueCreate(QUEUE_SIZE, sizeof(Packet *));
    	    qToRx4 = xQueueCreate(QUEUE_SIZE, sizeof(Packet *));
    	    qToSender1 = xQueueCreate(QUEUE_SIZE, sizeof(Packet *));
    	    qToSender2 = xQueueCreate(QUEUE_SIZE, sizeof(Packet *));
    	    configASSERT(qToSwitch);
    	    configASSERT(qToSwitch_ForACKs);
    	    configASSERT(qToRx3);
    	    configASSERT(qToRx4);
    	    configASSERT(qToSender1);
    	    configASSERT(qToSender2);
    }

    int main(int argc, char* argv[]) {
      //  srand((unsigned)time(NULL));
        setupQueues();

        stats_mutex = xSemaphoreCreateMutex();
           buf_mutex = xSemaphoreCreateMutex();
           configASSERT(stats_mutex);
           configASSERT(buf_mutex);
        memset(rx3_seenSeq, 0, sizeof(rx3_seenSeq));
        memset(rx4_seenSeq, 0, sizeof(rx4_seenSeq));

        memset(senderStates, 0, sizeof(senderStates));

        senderStates[0].myId = 1;

        senderStates[1].myId = 2;


        xTaskCreate(SenderTask, "Sender1", 2048, &senderStates[0], 1, NULL);
        xTaskCreate(SenderTask, "Sender2", 2048, &senderStates[1], 1, NULL);
        xTaskCreate(ReceiverTask, "Receiver3", 1024, (void*)3, 2, NULL);
        xTaskCreate(ReceiverTask, "Receiver4", 1024, (void*)4, 2, NULL);
        xTaskCreate(SwitchTask, "Switch", 1024, NULL, 1, NULL);

        startTick = xTaskGetTickCount();
        vTaskStartScheduler();

        return 0;
    }

    #pragma GCC diagnostic pop

    // ----------------------------------------------------------------------------
    void vApplicationMallocFailedHook(void) {
        printf("malloc failed\n");
        for (;;) ;
    }

    void vApplicationStackOverflowHook(TaskHandle_t pxTask, char *pcTaskName) {
        (void) pcTaskName;
        (void) pxTask;
        printf("stack overflow\n");
        for (;;) ;
    }

    void vApplicationIdleHook(void) {
        volatile size_t xFreeStackSpace;
        xFreeStackSpace = xPortGetFreeHeapSize();
        if (xFreeStackSpace > 100) {
            // Heap could be reduced
        }
    }

    void vApplicationTickHook(void) {
    }

    StaticTask_t xIdleTaskTCB CCM_RAM;
    StackType_t uxIdleTaskStack[configMINIMAL_STACK_SIZE] CCM_RAM;

    void vApplicationGetIdleTaskMemory(StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize) {
        *ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
        *ppxIdleTaskStackBuffer = uxIdleTaskStack;
        *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
    }

    static StaticTask_t xTimerTaskTCB CCM_RAM;
    static StackType_t uxTimerTaskStack[configTIMER_TASK_STACK_DEPTH] CCM_RAM;

    void vApplicationGetTimerTaskMemory(StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize) {
        *ppxTimerTaskTCBBuffer = &xTimerTaskTCB;
        *ppxTimerTaskStackBuffer = uxTimerTaskStack;
        *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
    }
