




#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "timers.h"
#include <string.h>
#include "semphr.h"

#define CCM_RAM __attribute__((section(".ccmram")))

#define MAX_RETRIES         4
#define PACKET_GEN_INTERVAL pdMS_TO_TICKS(100)
#define TIMEOUT_PERIOD      pdMS_TO_TICKS(200)
#define C_LINK_CAPACITY     100000
#define PROP_DELAY_MS       5
#define P_DROP_PERCENT      1
#define P_ACK_DROP          1
#define QUEUE_SIZE          40
#define TOTAL_PACKETS       2000

typedef struct {
    uint32_t seq;
    uint16_t sender_id;
    uint16_t receiver_id;
    uint16_t length;
    char     data[1500];
} Packet;

typedef struct {
    Packet* outstanding;
    TimerHandle_t timer;
    uint8_t retries;
    uint32_t next_seq;
    bool waiting_ack;
} SenderState;

static SemaphoreHandle_t stats_mutex;
static uint32_t total_received = 0;
static uint32_t total_transmissions = 0;
static uint32_t total_dropped = 0;
static QueueHandle_t network_queue, ack_queue;

// Simplified statistics tracking
static void update_stats(bool received) {
    xSemaphoreTake(stats_mutex, portMAX_DELAY);
    if(received) total_received++;
    else total_dropped++;
    xSemaphoreGive(stats_mutex);
}

// Unified packet generator
static Packet* generate_packet(uint16_t sender_id) {
    Packet* pkt = pvPortMalloc(sizeof(Packet));
    if(!pkt) return NULL;
    
    pkt->sender_id = sender_id;
    pkt->receiver_id = (rand() % 2) ? 3 : 4;  // Random receiver selection
    pkt->length = 500 + (rand() % 1001);      // Uniform [500,1500]
    pkt->seq = 0;  // Will be set by sender
    
    // Generate random data
    for(int i=0; i<sizeof(pkt->data)-1; i++)
        pkt->data[i] = 'A' + (rand() % 26);
    pkt->data[sizeof(pkt->data)-1] = '\0';
    
    return pkt;
}

// Simplified retransmission handler
static void retransmit_callback(TimerHandle_t timer) {
    SenderState* state = (SenderState*)pvTimerGetTimerID(timer);
    if(!state->outstanding || state->retries >= MAX_RETRIES) {
        update_stats(false);
        vPortFree(state->outstanding);
        state->outstanding = NULL;
        state->waiting_ack = false;
        return;
    }
    
    state->retries++;
    xQueueSend(network_queue, &state->outstanding, 0);
    xTimerReset(timer, 0);
    total_transmissions++;
}

// Unified sender task
static void sender_task(void* params) {
    SenderState state = {0};
    state.sender_id = (uint16_t)(uintptr_t)params;
    state.timer = xTimerCreate("TxTimer", TIMEOUT_PERIOD, pdFALSE, &state, retransmit_callback);
    
    while(total_received < TOTAL_PACKETS) {
        if(!state.waiting_ack) {
            state.outstanding = generate_packet(state.sender_id);
            if(state.outstanding) {
                state.outstanding->seq = state.next_seq++;
                state.retries = 0;
                xQueueSend(network_queue, &state.outstanding, 0);
                xTimerStart(state.timer, 0);
                state.waiting_ack = true;
                total_transmissions++;
            }
        }
        
        Packet* ack;
        if(xQueueReceive(ack_queue, &ack, PACKET_GEN_INTERVAL)) {
            if(ack->seq == state.outstanding->seq) {
                xTimerStop(state.timer, 0);
                vPortFree(state.outstanding);
                state.outstanding = NULL;
                state.waiting_ack = false;
            }
            vPortFree(ack);
        }
    }
    
    vTaskDelete(NULL);
}

// Unified receiver task
static void receiver_task(void* params) {
    Packet* pkt;
    while(total_received < TOTAL_PACKETS) {
        if(xQueueReceive(network_queue, &pkt, portMAX_DELAY) == pdPASS) {
            // Generate ACK
            Packet* ack = pvPortMalloc(sizeof(Packet));
            if(ack) {
                *ack = (Packet){
                    .seq = pkt->seq,
                    .sender_id = pkt->receiver_id,
                    .receiver_id = pkt->sender_id,
                    .length = 40
                };
                xQueueSend(ack_queue, &ack, 0);
            }
            
            update_stats(true);
            vPortFree(pkt);
        }
    }
    vTaskDelete(NULL);
}

// Simplified network simulation
static void network_task(void* params) {
    Packet* pkt;
    while(1) {
        if(xQueueReceive(network_queue, &pkt, portMAX_DELAY) == pdPASS) {
            // Simulate packet loss
            if((rand() % 100) < P_DROP_PERCENT) {
                update_stats(false);
                vPortFree(pkt);
                continue;
            }
            
            // Simulate network delay
            TickType_t delay = pdMS_TO_TICKS(
                PROP_DELAY_MS + 
                ((pkt->length * 8 * 1000) / C_LINK_CAPACITY)
            );
            vTaskDelay(delay);
            
            // Forward to receiver (simplified)
            xQueueSend(network_queue, &pkt, 0);
        }
    }
}

int main(void) {
    network_queue = xQueueCreate(QUEUE_SIZE, sizeof(Packet*));
    ack_queue = xQueueCreate(QUEUE_SIZE, sizeof(Packet*));
    stats_mutex = xSemaphoreCreateMutex();

    xTaskCreate(sender_task, "Sender1", 1024, (void*)1, 1, NULL);
    xTaskCreate(sender_task, "Sender2", 1024, (void*)2, 1, NULL);
    xTaskCreate(receiver_task, "Receiver", 1024, NULL, 2, NULL);
    xTaskCreate(network_task, "Network", 1024, NULL, 3, NULL);

    vTaskStartScheduler();
    
    // Final statistics output
    printf("Total Received: %u\n", total_received);
    printf("Total Dropped: %u\n", total_dropped);
    printf("Average Transmissions: %.2f\n", 
        (float)total_transmissions / total_received);
    
    return 0;
}

    #pragma GCC diagnostic pop

    // ----------------------------------------------------------------------------
    void vApplicationMallocFailedHook(void) {
        printf("malloc failed\n");
        for (;;) ;
    }

    void vApplicationStackOverflowHook(TaskHandle_t pxTask, char *pcTaskName) {
        (void) pcTaskName;
        (void) pxTask;
        printf("stack overflow\n");
        for (;;) ;
    }

    void vApplicationIdleHook(void) {
        volatile size_t xFreeStackSpace;
        xFreeStackSpace = xPortGetFreeHeapSize();
        if (xFreeStackSpace > 100) {
            // Heap could be reduced
        }
    }

    void vApplicationTickHook(void) {
    }

    StaticTask_t xIdleTaskTCB CCM_RAM;
    StackType_t uxIdleTaskStack[configMINIMAL_STACK_SIZE] CCM_RAM;

    void vApplicationGetIdleTaskMemory(StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize) {
        *ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
        *ppxIdleTaskStackBuffer = uxIdleTaskStack;
        *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
    }

    static StaticTask_t xTimerTaskTCB CCM_RAM;
    static StackType_t uxTimerTaskStack[configTIMER_TASK_STACK_DEPTH] CCM_RAM;

    void vApplicationGetTimerTaskMemory(StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize) {
        *ppxTimerTaskTCBBuffer = &xTimerTaskTCB;
        *ppxTimerTaskStackBuffer = uxTimerTaskStack;
        *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
    }

